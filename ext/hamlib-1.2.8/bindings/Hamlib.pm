# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.33
#
# Don't modify this file, modify the SWIG interface instead.

package Hamlib;
require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);
package Hamlibc;
bootstrap Hamlib;
package Hamlib;
@EXPORT = qw( );

# ---------- BASE METHODS -------------

package Hamlib;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Hamlib;

*rig_init = *Hamlibc::rig_init;
*rig_set_split_vfo = *Hamlibc::rig_set_split_vfo;
*rig_get_split_vfo = *Hamlibc::rig_get_split_vfo;
*rig_ext_lookup = *Hamlibc::rig_ext_lookup;
*rig_ext_lookup_tok = *Hamlibc::rig_ext_lookup_tok;
*rig_ext_token_lookup = *Hamlibc::rig_ext_token_lookup;
*rig_token_foreach = *Hamlibc::rig_token_foreach;
*rig_confparam_lookup = *Hamlibc::rig_confparam_lookup;
*rig_set_chan_all = *Hamlibc::rig_set_chan_all;
*rig_get_chan_all = *Hamlibc::rig_get_chan_all;
*rig_set_chan_all_cb = *Hamlibc::rig_set_chan_all_cb;
*rig_get_chan_all_cb = *Hamlibc::rig_get_chan_all_cb;
*rig_set_mem_all_cb = *Hamlibc::rig_set_mem_all_cb;
*rig_get_mem_all_cb = *Hamlibc::rig_get_mem_all_cb;
*rig_set_mem_all = *Hamlibc::rig_set_mem_all;
*rig_get_mem_all = *Hamlibc::rig_get_mem_all;
*rig_lookup_mem_caps = *Hamlibc::rig_lookup_mem_caps;
*rig_mem_count = *Hamlibc::rig_mem_count;
*rig_get_caps = *Hamlibc::rig_get_caps;
*rig_get_range = *Hamlibc::rig_get_range;
*rigerror = *Hamlibc::rigerror;
*rig_setting2idx = *Hamlibc::rig_setting2idx;
*rig_set_debug = *Hamlibc::rig_set_debug;
*rig_need_debug = *Hamlibc::rig_need_debug;
*rig_set_debug_callback = *Hamlibc::rig_set_debug_callback;
*rig_set_debug_file = *Hamlibc::rig_set_debug_file;
*rig_register = *Hamlibc::rig_register;
*rig_unregister = *Hamlibc::rig_unregister;
*rig_list_foreach = *Hamlibc::rig_list_foreach;
*rig_load_backend = *Hamlibc::rig_load_backend;
*rig_check_backend = *Hamlibc::rig_check_backend;
*rig_load_all_backends = *Hamlibc::rig_load_all_backends;
*rig_probe_all = *Hamlibc::rig_probe_all;
*rig_strrmode = *Hamlibc::rig_strrmode;
*rig_strvfo = *Hamlibc::rig_strvfo;
*rig_strfunc = *Hamlibc::rig_strfunc;
*rig_strlevel = *Hamlibc::rig_strlevel;
*rig_strparm = *Hamlibc::rig_strparm;
*rig_strptrshift = *Hamlibc::rig_strptrshift;
*rig_strvfop = *Hamlibc::rig_strvfop;
*rig_strscan = *Hamlibc::rig_strscan;
*rig_strstatus = *Hamlibc::rig_strstatus;
*rig_strmtype = *Hamlibc::rig_strmtype;
*rig_parse_mode = *Hamlibc::rig_parse_mode;
*rig_parse_vfo = *Hamlibc::rig_parse_vfo;
*rig_parse_func = *Hamlibc::rig_parse_func;
*rig_parse_level = *Hamlibc::rig_parse_level;
*rig_parse_parm = *Hamlibc::rig_parse_parm;
*rig_parse_vfo_op = *Hamlibc::rig_parse_vfo_op;
*rig_parse_scan = *Hamlibc::rig_parse_scan;
*rig_parse_rptr_shift = *Hamlibc::rig_parse_rptr_shift;
*rig_parse_mtype = *Hamlibc::rig_parse_mtype;
*rot_init = *Hamlibc::rot_init;
*rot_register = *Hamlibc::rot_register;
*rot_unregister = *Hamlibc::rot_unregister;
*rot_list_foreach = *Hamlibc::rot_list_foreach;
*rot_load_backend = *Hamlibc::rot_load_backend;
*rot_check_backend = *Hamlibc::rot_check_backend;
*rot_load_all_backends = *Hamlibc::rot_load_all_backends;
*rot_probe_all = *Hamlibc::rot_probe_all;
*rot_token_foreach = *Hamlibc::rot_token_foreach;
*rot_confparam_lookup = *Hamlibc::rot_confparam_lookup;
*rot_token_lookup = *Hamlibc::rot_token_lookup;
*rot_get_caps = *Hamlibc::rot_get_caps;
*qrb = *Hamlibc::qrb;
*distance_long_path = *Hamlibc::distance_long_path;
*azimuth_long_path = *Hamlibc::azimuth_long_path;
*longlat2locator = *Hamlibc::longlat2locator;
*locator2longlat = *Hamlibc::locator2longlat;
*dms2dec = *Hamlibc::dms2dec;
*dec2dms = *Hamlibc::dec2dms;
*dec2dmmm = *Hamlibc::dec2dmmm;
*dmmm2dec = *Hamlibc::dmmm2dec;

############# Class : Hamlib::confparams ##############

package Hamlib::confparams;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_token_get = *Hamlibc::confparams_token_get;
*swig_token_set = *Hamlibc::confparams_token_set;
*swig_name_get = *Hamlibc::confparams_name_get;
*swig_name_set = *Hamlibc::confparams_name_set;
*swig_label_get = *Hamlibc::confparams_label_get;
*swig_label_set = *Hamlibc::confparams_label_set;
*swig_tooltip_get = *Hamlibc::confparams_tooltip_get;
*swig_tooltip_set = *Hamlibc::confparams_tooltip_set;
*swig_dflt_get = *Hamlibc::confparams_dflt_get;
*swig_dflt_set = *Hamlibc::confparams_dflt_set;
*swig_type_get = *Hamlibc::confparams_type_get;
*swig_type_set = *Hamlibc::confparams_type_set;
*swig_u_get = *Hamlibc::confparams_u_get;
*swig_u_set = *Hamlibc::confparams_u_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_confparams(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_confparams($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::confparams_u ##############

package Hamlib::confparams_u;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_c_get = *Hamlibc::confparams_u_c_get;
*swig_c_set = *Hamlibc::confparams_u_c_set;
*swig_n_get = *Hamlibc::confparams_u_n_get;
*swig_n_set = *Hamlibc::confparams_u_n_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_confparams_u(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_confparams_u($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::confparams_u_c ##############

package Hamlib::confparams_u_c;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_combostr_get = *Hamlibc::confparams_u_c_combostr_get;
*swig_combostr_set = *Hamlibc::confparams_u_c_combostr_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_confparams_u_c(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_confparams_u_c($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::confparams_u_n ##############

package Hamlib::confparams_u_n;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_min_get = *Hamlibc::confparams_u_n_min_get;
*swig_min_set = *Hamlibc::confparams_u_n_min_set;
*swig_max_get = *Hamlibc::confparams_u_n_max_get;
*swig_max_set = *Hamlibc::confparams_u_n_max_set;
*swig_step_get = *Hamlibc::confparams_u_n_step_get;
*swig_step_set = *Hamlibc::confparams_u_n_step_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_confparams_u_n(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_confparams_u_n($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::value_t ##############

package Hamlib::value_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_i_get = *Hamlibc::value_t_i_get;
*swig_i_set = *Hamlibc::value_t_i_set;
*swig_f_get = *Hamlibc::value_t_f_get;
*swig_f_set = *Hamlibc::value_t_f_set;
*swig_s_get = *Hamlibc::value_t_s_get;
*swig_s_set = *Hamlibc::value_t_s_set;
*swig_cs_get = *Hamlibc::value_t_cs_get;
*swig_cs_set = *Hamlibc::value_t_cs_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_value_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_value_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::freq_range_t ##############

package Hamlib::freq_range_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_start_get = *Hamlibc::freq_range_t_start_get;
*swig_start_set = *Hamlibc::freq_range_t_start_set;
*swig_end_get = *Hamlibc::freq_range_t_end_get;
*swig_end_set = *Hamlibc::freq_range_t_end_set;
*swig_modes_get = *Hamlibc::freq_range_t_modes_get;
*swig_modes_set = *Hamlibc::freq_range_t_modes_set;
*swig_low_power_get = *Hamlibc::freq_range_t_low_power_get;
*swig_low_power_set = *Hamlibc::freq_range_t_low_power_set;
*swig_high_power_get = *Hamlibc::freq_range_t_high_power_get;
*swig_high_power_set = *Hamlibc::freq_range_t_high_power_set;
*swig_vfo_get = *Hamlibc::freq_range_t_vfo_get;
*swig_vfo_set = *Hamlibc::freq_range_t_vfo_set;
*swig_ant_get = *Hamlibc::freq_range_t_ant_get;
*swig_ant_set = *Hamlibc::freq_range_t_ant_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_freq_range_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_freq_range_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::tuning_step_list ##############

package Hamlib::tuning_step_list;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_modes_get = *Hamlibc::tuning_step_list_modes_get;
*swig_modes_set = *Hamlibc::tuning_step_list_modes_set;
*swig_ts_get = *Hamlibc::tuning_step_list_ts_get;
*swig_ts_set = *Hamlibc::tuning_step_list_ts_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_tuning_step_list(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_tuning_step_list($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::filter_list ##############

package Hamlib::filter_list;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_modes_get = *Hamlibc::filter_list_modes_get;
*swig_modes_set = *Hamlibc::filter_list_modes_set;
*swig_width_get = *Hamlibc::filter_list_width_get;
*swig_width_set = *Hamlibc::filter_list_width_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_filter_list(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_filter_list($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::ext_list ##############

package Hamlib::ext_list;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_token_get = *Hamlibc::ext_list_token_get;
*swig_token_set = *Hamlibc::ext_list_token_set;
*swig_val_get = *Hamlibc::ext_list_val_get;
*swig_val_set = *Hamlibc::ext_list_val_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_ext_list(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_ext_list($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::channel ##############

package Hamlib::channel;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_channel_num_get = *Hamlibc::channel_channel_num_get;
*swig_channel_num_set = *Hamlibc::channel_channel_num_set;
*swig_bank_num_get = *Hamlibc::channel_bank_num_get;
*swig_bank_num_set = *Hamlibc::channel_bank_num_set;
*swig_vfo_get = *Hamlibc::channel_vfo_get;
*swig_vfo_set = *Hamlibc::channel_vfo_set;
*swig_ant_get = *Hamlibc::channel_ant_get;
*swig_ant_set = *Hamlibc::channel_ant_set;
*swig_freq_get = *Hamlibc::channel_freq_get;
*swig_freq_set = *Hamlibc::channel_freq_set;
*swig_mode_get = *Hamlibc::channel_mode_get;
*swig_mode_set = *Hamlibc::channel_mode_set;
*swig_width_get = *Hamlibc::channel_width_get;
*swig_width_set = *Hamlibc::channel_width_set;
*swig_tx_freq_get = *Hamlibc::channel_tx_freq_get;
*swig_tx_freq_set = *Hamlibc::channel_tx_freq_set;
*swig_tx_mode_get = *Hamlibc::channel_tx_mode_get;
*swig_tx_mode_set = *Hamlibc::channel_tx_mode_set;
*swig_tx_width_get = *Hamlibc::channel_tx_width_get;
*swig_tx_width_set = *Hamlibc::channel_tx_width_set;
*swig_split_get = *Hamlibc::channel_split_get;
*swig_split_set = *Hamlibc::channel_split_set;
*swig_tx_vfo_get = *Hamlibc::channel_tx_vfo_get;
*swig_tx_vfo_set = *Hamlibc::channel_tx_vfo_set;
*swig_rptr_shift_get = *Hamlibc::channel_rptr_shift_get;
*swig_rptr_shift_set = *Hamlibc::channel_rptr_shift_set;
*swig_rptr_offs_get = *Hamlibc::channel_rptr_offs_get;
*swig_rptr_offs_set = *Hamlibc::channel_rptr_offs_set;
*swig_tuning_step_get = *Hamlibc::channel_tuning_step_get;
*swig_tuning_step_set = *Hamlibc::channel_tuning_step_set;
*swig_rit_get = *Hamlibc::channel_rit_get;
*swig_rit_set = *Hamlibc::channel_rit_set;
*swig_xit_get = *Hamlibc::channel_xit_get;
*swig_xit_set = *Hamlibc::channel_xit_set;
*swig_funcs_get = *Hamlibc::channel_funcs_get;
*swig_funcs_set = *Hamlibc::channel_funcs_set;
*swig_levels_get = *Hamlibc::channel_levels_get;
*swig_levels_set = *Hamlibc::channel_levels_set;
*swig_ctcss_tone_get = *Hamlibc::channel_ctcss_tone_get;
*swig_ctcss_tone_set = *Hamlibc::channel_ctcss_tone_set;
*swig_ctcss_sql_get = *Hamlibc::channel_ctcss_sql_get;
*swig_ctcss_sql_set = *Hamlibc::channel_ctcss_sql_set;
*swig_dcs_code_get = *Hamlibc::channel_dcs_code_get;
*swig_dcs_code_set = *Hamlibc::channel_dcs_code_set;
*swig_dcs_sql_get = *Hamlibc::channel_dcs_sql_get;
*swig_dcs_sql_set = *Hamlibc::channel_dcs_sql_set;
*swig_scan_group_get = *Hamlibc::channel_scan_group_get;
*swig_scan_group_set = *Hamlibc::channel_scan_group_set;
*swig_flags_get = *Hamlibc::channel_flags_get;
*swig_flags_set = *Hamlibc::channel_flags_set;
*swig_channel_desc_get = *Hamlibc::channel_channel_desc_get;
*swig_channel_desc_set = *Hamlibc::channel_channel_desc_set;
*swig_ext_levels_get = *Hamlibc::channel_ext_levels_get;
*swig_ext_levels_set = *Hamlibc::channel_ext_levels_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_channel(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_channel($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::channel_cap ##############

package Hamlib::channel_cap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_bank_num_get = *Hamlibc::channel_cap_bank_num_get;
*swig_bank_num_set = *Hamlibc::channel_cap_bank_num_set;
*swig_vfo_get = *Hamlibc::channel_cap_vfo_get;
*swig_vfo_set = *Hamlibc::channel_cap_vfo_set;
*swig_ant_get = *Hamlibc::channel_cap_ant_get;
*swig_ant_set = *Hamlibc::channel_cap_ant_set;
*swig_freq_get = *Hamlibc::channel_cap_freq_get;
*swig_freq_set = *Hamlibc::channel_cap_freq_set;
*swig_mode_get = *Hamlibc::channel_cap_mode_get;
*swig_mode_set = *Hamlibc::channel_cap_mode_set;
*swig_width_get = *Hamlibc::channel_cap_width_get;
*swig_width_set = *Hamlibc::channel_cap_width_set;
*swig_tx_freq_get = *Hamlibc::channel_cap_tx_freq_get;
*swig_tx_freq_set = *Hamlibc::channel_cap_tx_freq_set;
*swig_tx_mode_get = *Hamlibc::channel_cap_tx_mode_get;
*swig_tx_mode_set = *Hamlibc::channel_cap_tx_mode_set;
*swig_tx_width_get = *Hamlibc::channel_cap_tx_width_get;
*swig_tx_width_set = *Hamlibc::channel_cap_tx_width_set;
*swig_split_get = *Hamlibc::channel_cap_split_get;
*swig_split_set = *Hamlibc::channel_cap_split_set;
*swig_tx_vfo_get = *Hamlibc::channel_cap_tx_vfo_get;
*swig_tx_vfo_set = *Hamlibc::channel_cap_tx_vfo_set;
*swig_rptr_shift_get = *Hamlibc::channel_cap_rptr_shift_get;
*swig_rptr_shift_set = *Hamlibc::channel_cap_rptr_shift_set;
*swig_rptr_offs_get = *Hamlibc::channel_cap_rptr_offs_get;
*swig_rptr_offs_set = *Hamlibc::channel_cap_rptr_offs_set;
*swig_tuning_step_get = *Hamlibc::channel_cap_tuning_step_get;
*swig_tuning_step_set = *Hamlibc::channel_cap_tuning_step_set;
*swig_rit_get = *Hamlibc::channel_cap_rit_get;
*swig_rit_set = *Hamlibc::channel_cap_rit_set;
*swig_xit_get = *Hamlibc::channel_cap_xit_get;
*swig_xit_set = *Hamlibc::channel_cap_xit_set;
*swig_funcs_get = *Hamlibc::channel_cap_funcs_get;
*swig_funcs_set = *Hamlibc::channel_cap_funcs_set;
*swig_levels_get = *Hamlibc::channel_cap_levels_get;
*swig_levels_set = *Hamlibc::channel_cap_levels_set;
*swig_ctcss_tone_get = *Hamlibc::channel_cap_ctcss_tone_get;
*swig_ctcss_tone_set = *Hamlibc::channel_cap_ctcss_tone_set;
*swig_ctcss_sql_get = *Hamlibc::channel_cap_ctcss_sql_get;
*swig_ctcss_sql_set = *Hamlibc::channel_cap_ctcss_sql_set;
*swig_dcs_code_get = *Hamlibc::channel_cap_dcs_code_get;
*swig_dcs_code_set = *Hamlibc::channel_cap_dcs_code_set;
*swig_dcs_sql_get = *Hamlibc::channel_cap_dcs_sql_get;
*swig_dcs_sql_set = *Hamlibc::channel_cap_dcs_sql_set;
*swig_scan_group_get = *Hamlibc::channel_cap_scan_group_get;
*swig_scan_group_set = *Hamlibc::channel_cap_scan_group_set;
*swig_flags_get = *Hamlibc::channel_cap_flags_get;
*swig_flags_set = *Hamlibc::channel_cap_flags_set;
*swig_channel_desc_get = *Hamlibc::channel_cap_channel_desc_get;
*swig_channel_desc_set = *Hamlibc::channel_cap_channel_desc_set;
*swig_ext_levels_get = *Hamlibc::channel_cap_ext_levels_get;
*swig_ext_levels_set = *Hamlibc::channel_cap_ext_levels_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_channel_cap(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_channel_cap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::chan_list ##############

package Hamlib::chan_list;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_start_get = *Hamlibc::chan_list_start_get;
*swig_start_set = *Hamlibc::chan_list_start_set;
*swig_end_get = *Hamlibc::chan_list_end_get;
*swig_end_set = *Hamlibc::chan_list_end_set;
*swig_type_get = *Hamlibc::chan_list_type_get;
*swig_type_set = *Hamlibc::chan_list_type_set;
*swig_mem_caps_get = *Hamlibc::chan_list_mem_caps_get;
*swig_mem_caps_set = *Hamlibc::chan_list_mem_caps_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_chan_list(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_chan_list($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::gran ##############

package Hamlib::gran;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_min_get = *Hamlibc::gran_min_get;
*swig_min_set = *Hamlibc::gran_min_set;
*swig_max_get = *Hamlibc::gran_max_get;
*swig_max_set = *Hamlibc::gran_max_set;
*swig_step_get = *Hamlibc::gran_step_get;
*swig_step_set = *Hamlibc::gran_step_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_gran(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_gran($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::cal_table ##############

package Hamlib::cal_table;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_size_get = *Hamlibc::cal_table_size_get;
*swig_size_set = *Hamlibc::cal_table_size_set;
*swig_table_get = *Hamlibc::cal_table_table_get;
*swig_table_set = *Hamlibc::cal_table_table_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_cal_table(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_cal_table($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::cal_table_table ##############

package Hamlib::cal_table_table;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_raw_get = *Hamlibc::cal_table_table_raw_get;
*swig_raw_set = *Hamlibc::cal_table_table_raw_set;
*swig_val_get = *Hamlibc::cal_table_table_val_get;
*swig_val_set = *Hamlibc::cal_table_table_val_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_cal_table_table(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_cal_table_table($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::rig_caps ##############

package Hamlib::rig_caps;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_rig_model_get = *Hamlibc::rig_caps_rig_model_get;
*swig_rig_model_set = *Hamlibc::rig_caps_rig_model_set;
*swig_model_name_get = *Hamlibc::rig_caps_model_name_get;
*swig_model_name_set = *Hamlibc::rig_caps_model_name_set;
*swig_mfg_name_get = *Hamlibc::rig_caps_mfg_name_get;
*swig_mfg_name_set = *Hamlibc::rig_caps_mfg_name_set;
*swig_version_get = *Hamlibc::rig_caps_version_get;
*swig_version_set = *Hamlibc::rig_caps_version_set;
*swig_copyright_get = *Hamlibc::rig_caps_copyright_get;
*swig_copyright_set = *Hamlibc::rig_caps_copyright_set;
*swig_status_get = *Hamlibc::rig_caps_status_get;
*swig_status_set = *Hamlibc::rig_caps_status_set;
*swig_rig_type_get = *Hamlibc::rig_caps_rig_type_get;
*swig_rig_type_set = *Hamlibc::rig_caps_rig_type_set;
*swig_ptt_type_get = *Hamlibc::rig_caps_ptt_type_get;
*swig_ptt_type_set = *Hamlibc::rig_caps_ptt_type_set;
*swig_dcd_type_get = *Hamlibc::rig_caps_dcd_type_get;
*swig_dcd_type_set = *Hamlibc::rig_caps_dcd_type_set;
*swig_port_type_get = *Hamlibc::rig_caps_port_type_get;
*swig_port_type_set = *Hamlibc::rig_caps_port_type_set;
*swig_serial_rate_min_get = *Hamlibc::rig_caps_serial_rate_min_get;
*swig_serial_rate_min_set = *Hamlibc::rig_caps_serial_rate_min_set;
*swig_serial_rate_max_get = *Hamlibc::rig_caps_serial_rate_max_get;
*swig_serial_rate_max_set = *Hamlibc::rig_caps_serial_rate_max_set;
*swig_serial_data_bits_get = *Hamlibc::rig_caps_serial_data_bits_get;
*swig_serial_data_bits_set = *Hamlibc::rig_caps_serial_data_bits_set;
*swig_serial_stop_bits_get = *Hamlibc::rig_caps_serial_stop_bits_get;
*swig_serial_stop_bits_set = *Hamlibc::rig_caps_serial_stop_bits_set;
*swig_serial_parity_get = *Hamlibc::rig_caps_serial_parity_get;
*swig_serial_parity_set = *Hamlibc::rig_caps_serial_parity_set;
*swig_serial_handshake_get = *Hamlibc::rig_caps_serial_handshake_get;
*swig_serial_handshake_set = *Hamlibc::rig_caps_serial_handshake_set;
*swig_write_delay_get = *Hamlibc::rig_caps_write_delay_get;
*swig_write_delay_set = *Hamlibc::rig_caps_write_delay_set;
*swig_post_write_delay_get = *Hamlibc::rig_caps_post_write_delay_get;
*swig_post_write_delay_set = *Hamlibc::rig_caps_post_write_delay_set;
*swig_timeout_get = *Hamlibc::rig_caps_timeout_get;
*swig_timeout_set = *Hamlibc::rig_caps_timeout_set;
*swig_retry_get = *Hamlibc::rig_caps_retry_get;
*swig_retry_set = *Hamlibc::rig_caps_retry_set;
*swig_has_get_func_get = *Hamlibc::rig_caps_has_get_func_get;
*swig_has_get_func_set = *Hamlibc::rig_caps_has_get_func_set;
*swig_has_set_func_get = *Hamlibc::rig_caps_has_set_func_get;
*swig_has_set_func_set = *Hamlibc::rig_caps_has_set_func_set;
*swig_has_get_level_get = *Hamlibc::rig_caps_has_get_level_get;
*swig_has_get_level_set = *Hamlibc::rig_caps_has_get_level_set;
*swig_has_set_level_get = *Hamlibc::rig_caps_has_set_level_get;
*swig_has_set_level_set = *Hamlibc::rig_caps_has_set_level_set;
*swig_has_get_parm_get = *Hamlibc::rig_caps_has_get_parm_get;
*swig_has_get_parm_set = *Hamlibc::rig_caps_has_get_parm_set;
*swig_has_set_parm_get = *Hamlibc::rig_caps_has_set_parm_get;
*swig_has_set_parm_set = *Hamlibc::rig_caps_has_set_parm_set;
*swig_level_gran_get = *Hamlibc::rig_caps_level_gran_get;
*swig_level_gran_set = *Hamlibc::rig_caps_level_gran_set;
*swig_parm_gran_get = *Hamlibc::rig_caps_parm_gran_get;
*swig_parm_gran_set = *Hamlibc::rig_caps_parm_gran_set;
*swig_extparms_get = *Hamlibc::rig_caps_extparms_get;
*swig_extparms_set = *Hamlibc::rig_caps_extparms_set;
*swig_extlevels_get = *Hamlibc::rig_caps_extlevels_get;
*swig_extlevels_set = *Hamlibc::rig_caps_extlevels_set;
*swig_ctcss_list_get = *Hamlibc::rig_caps_ctcss_list_get;
*swig_ctcss_list_set = *Hamlibc::rig_caps_ctcss_list_set;
*swig_dcs_list_get = *Hamlibc::rig_caps_dcs_list_get;
*swig_dcs_list_set = *Hamlibc::rig_caps_dcs_list_set;
*swig_preamp_get = *Hamlibc::rig_caps_preamp_get;
*swig_preamp_set = *Hamlibc::rig_caps_preamp_set;
*swig_attenuator_get = *Hamlibc::rig_caps_attenuator_get;
*swig_attenuator_set = *Hamlibc::rig_caps_attenuator_set;
*swig_max_rit_get = *Hamlibc::rig_caps_max_rit_get;
*swig_max_rit_set = *Hamlibc::rig_caps_max_rit_set;
*swig_max_xit_get = *Hamlibc::rig_caps_max_xit_get;
*swig_max_xit_set = *Hamlibc::rig_caps_max_xit_set;
*swig_max_ifshift_get = *Hamlibc::rig_caps_max_ifshift_get;
*swig_max_ifshift_set = *Hamlibc::rig_caps_max_ifshift_set;
*swig_announces_get = *Hamlibc::rig_caps_announces_get;
*swig_announces_set = *Hamlibc::rig_caps_announces_set;
*swig_vfo_ops_get = *Hamlibc::rig_caps_vfo_ops_get;
*swig_vfo_ops_set = *Hamlibc::rig_caps_vfo_ops_set;
*swig_scan_ops_get = *Hamlibc::rig_caps_scan_ops_get;
*swig_scan_ops_set = *Hamlibc::rig_caps_scan_ops_set;
*swig_targetable_vfo_get = *Hamlibc::rig_caps_targetable_vfo_get;
*swig_targetable_vfo_set = *Hamlibc::rig_caps_targetable_vfo_set;
*swig_transceive_get = *Hamlibc::rig_caps_transceive_get;
*swig_transceive_set = *Hamlibc::rig_caps_transceive_set;
*swig_bank_qty_get = *Hamlibc::rig_caps_bank_qty_get;
*swig_bank_qty_set = *Hamlibc::rig_caps_bank_qty_set;
*swig_chan_desc_sz_get = *Hamlibc::rig_caps_chan_desc_sz_get;
*swig_chan_desc_sz_set = *Hamlibc::rig_caps_chan_desc_sz_set;
*swig_chan_list_get = *Hamlibc::rig_caps_chan_list_get;
*swig_chan_list_set = *Hamlibc::rig_caps_chan_list_set;
*swig_rx_range_list1_get = *Hamlibc::rig_caps_rx_range_list1_get;
*swig_rx_range_list1_set = *Hamlibc::rig_caps_rx_range_list1_set;
*swig_tx_range_list1_get = *Hamlibc::rig_caps_tx_range_list1_get;
*swig_tx_range_list1_set = *Hamlibc::rig_caps_tx_range_list1_set;
*swig_rx_range_list2_get = *Hamlibc::rig_caps_rx_range_list2_get;
*swig_rx_range_list2_set = *Hamlibc::rig_caps_rx_range_list2_set;
*swig_tx_range_list2_get = *Hamlibc::rig_caps_tx_range_list2_get;
*swig_tx_range_list2_set = *Hamlibc::rig_caps_tx_range_list2_set;
*swig_tuning_steps_get = *Hamlibc::rig_caps_tuning_steps_get;
*swig_tuning_steps_set = *Hamlibc::rig_caps_tuning_steps_set;
*swig_filters_get = *Hamlibc::rig_caps_filters_get;
*swig_filters_set = *Hamlibc::rig_caps_filters_set;
*swig_str_cal_get = *Hamlibc::rig_caps_str_cal_get;
*swig_str_cal_set = *Hamlibc::rig_caps_str_cal_set;
*swig_cfgparams_get = *Hamlibc::rig_caps_cfgparams_get;
*swig_cfgparams_set = *Hamlibc::rig_caps_cfgparams_set;
*swig_priv_get = *Hamlibc::rig_caps_priv_get;
*swig_priv_set = *Hamlibc::rig_caps_priv_set;
*swig_rig_init_get = *Hamlibc::rig_caps_rig_init_get;
*swig_rig_init_set = *Hamlibc::rig_caps_rig_init_set;
*swig_set_freq_get = *Hamlibc::rig_caps_set_freq_get;
*swig_set_freq_set = *Hamlibc::rig_caps_set_freq_set;
*swig_get_freq_get = *Hamlibc::rig_caps_get_freq_get;
*swig_get_freq_set = *Hamlibc::rig_caps_get_freq_set;
*swig_set_mode_get = *Hamlibc::rig_caps_set_mode_get;
*swig_set_mode_set = *Hamlibc::rig_caps_set_mode_set;
*swig_get_mode_get = *Hamlibc::rig_caps_get_mode_get;
*swig_get_mode_set = *Hamlibc::rig_caps_get_mode_set;
*swig_set_vfo_get = *Hamlibc::rig_caps_set_vfo_get;
*swig_set_vfo_set = *Hamlibc::rig_caps_set_vfo_set;
*swig_get_vfo_get = *Hamlibc::rig_caps_get_vfo_get;
*swig_get_vfo_set = *Hamlibc::rig_caps_get_vfo_set;
*swig_set_ptt_get = *Hamlibc::rig_caps_set_ptt_get;
*swig_set_ptt_set = *Hamlibc::rig_caps_set_ptt_set;
*swig_get_ptt_get = *Hamlibc::rig_caps_get_ptt_get;
*swig_get_ptt_set = *Hamlibc::rig_caps_get_ptt_set;
*swig_get_dcd_get = *Hamlibc::rig_caps_get_dcd_get;
*swig_get_dcd_set = *Hamlibc::rig_caps_get_dcd_set;
*swig_set_rptr_shift_get = *Hamlibc::rig_caps_set_rptr_shift_get;
*swig_set_rptr_shift_set = *Hamlibc::rig_caps_set_rptr_shift_set;
*swig_get_rptr_shift_get = *Hamlibc::rig_caps_get_rptr_shift_get;
*swig_get_rptr_shift_set = *Hamlibc::rig_caps_get_rptr_shift_set;
*swig_set_rptr_offs_get = *Hamlibc::rig_caps_set_rptr_offs_get;
*swig_set_rptr_offs_set = *Hamlibc::rig_caps_set_rptr_offs_set;
*swig_get_rptr_offs_get = *Hamlibc::rig_caps_get_rptr_offs_get;
*swig_get_rptr_offs_set = *Hamlibc::rig_caps_get_rptr_offs_set;
*swig_set_split_freq_get = *Hamlibc::rig_caps_set_split_freq_get;
*swig_set_split_freq_set = *Hamlibc::rig_caps_set_split_freq_set;
*swig_get_split_freq_get = *Hamlibc::rig_caps_get_split_freq_get;
*swig_get_split_freq_set = *Hamlibc::rig_caps_get_split_freq_set;
*swig_set_split_mode_get = *Hamlibc::rig_caps_set_split_mode_get;
*swig_set_split_mode_set = *Hamlibc::rig_caps_set_split_mode_set;
*swig_get_split_mode_get = *Hamlibc::rig_caps_get_split_mode_get;
*swig_get_split_mode_set = *Hamlibc::rig_caps_get_split_mode_set;
*swig_set_split_vfo_get = *Hamlibc::rig_caps_set_split_vfo_get;
*swig_set_split_vfo_set = *Hamlibc::rig_caps_set_split_vfo_set;
*swig_get_split_vfo_get = *Hamlibc::rig_caps_get_split_vfo_get;
*swig_get_split_vfo_set = *Hamlibc::rig_caps_get_split_vfo_set;
*swig_set_rit_get = *Hamlibc::rig_caps_set_rit_get;
*swig_set_rit_set = *Hamlibc::rig_caps_set_rit_set;
*swig_get_rit_get = *Hamlibc::rig_caps_get_rit_get;
*swig_get_rit_set = *Hamlibc::rig_caps_get_rit_set;
*swig_set_xit_get = *Hamlibc::rig_caps_set_xit_get;
*swig_set_xit_set = *Hamlibc::rig_caps_set_xit_set;
*swig_get_xit_get = *Hamlibc::rig_caps_get_xit_get;
*swig_get_xit_set = *Hamlibc::rig_caps_get_xit_set;
*swig_set_ts_get = *Hamlibc::rig_caps_set_ts_get;
*swig_set_ts_set = *Hamlibc::rig_caps_set_ts_set;
*swig_get_ts_get = *Hamlibc::rig_caps_get_ts_get;
*swig_get_ts_set = *Hamlibc::rig_caps_get_ts_set;
*swig_set_dcs_code_get = *Hamlibc::rig_caps_set_dcs_code_get;
*swig_set_dcs_code_set = *Hamlibc::rig_caps_set_dcs_code_set;
*swig_get_dcs_code_get = *Hamlibc::rig_caps_get_dcs_code_get;
*swig_get_dcs_code_set = *Hamlibc::rig_caps_get_dcs_code_set;
*swig_set_tone_get = *Hamlibc::rig_caps_set_tone_get;
*swig_set_tone_set = *Hamlibc::rig_caps_set_tone_set;
*swig_get_tone_get = *Hamlibc::rig_caps_get_tone_get;
*swig_get_tone_set = *Hamlibc::rig_caps_get_tone_set;
*swig_set_ctcss_tone_get = *Hamlibc::rig_caps_set_ctcss_tone_get;
*swig_set_ctcss_tone_set = *Hamlibc::rig_caps_set_ctcss_tone_set;
*swig_get_ctcss_tone_get = *Hamlibc::rig_caps_get_ctcss_tone_get;
*swig_get_ctcss_tone_set = *Hamlibc::rig_caps_get_ctcss_tone_set;
*swig_set_dcs_sql_get = *Hamlibc::rig_caps_set_dcs_sql_get;
*swig_set_dcs_sql_set = *Hamlibc::rig_caps_set_dcs_sql_set;
*swig_get_dcs_sql_get = *Hamlibc::rig_caps_get_dcs_sql_get;
*swig_get_dcs_sql_set = *Hamlibc::rig_caps_get_dcs_sql_set;
*swig_set_tone_sql_get = *Hamlibc::rig_caps_set_tone_sql_get;
*swig_set_tone_sql_set = *Hamlibc::rig_caps_set_tone_sql_set;
*swig_get_tone_sql_get = *Hamlibc::rig_caps_get_tone_sql_get;
*swig_get_tone_sql_set = *Hamlibc::rig_caps_get_tone_sql_set;
*swig_set_ctcss_sql_get = *Hamlibc::rig_caps_set_ctcss_sql_get;
*swig_set_ctcss_sql_set = *Hamlibc::rig_caps_set_ctcss_sql_set;
*swig_get_ctcss_sql_get = *Hamlibc::rig_caps_get_ctcss_sql_get;
*swig_get_ctcss_sql_set = *Hamlibc::rig_caps_get_ctcss_sql_set;
*swig_power2mW_get = *Hamlibc::rig_caps_power2mW_get;
*swig_power2mW_set = *Hamlibc::rig_caps_power2mW_set;
*swig_mW2power_get = *Hamlibc::rig_caps_mW2power_get;
*swig_mW2power_set = *Hamlibc::rig_caps_mW2power_set;
*swig_set_powerstat_get = *Hamlibc::rig_caps_set_powerstat_get;
*swig_set_powerstat_set = *Hamlibc::rig_caps_set_powerstat_set;
*swig_get_powerstat_get = *Hamlibc::rig_caps_get_powerstat_get;
*swig_get_powerstat_set = *Hamlibc::rig_caps_get_powerstat_set;
*swig_reset_get = *Hamlibc::rig_caps_reset_get;
*swig_reset_set = *Hamlibc::rig_caps_reset_set;
*swig_set_ant_get = *Hamlibc::rig_caps_set_ant_get;
*swig_set_ant_set = *Hamlibc::rig_caps_set_ant_set;
*swig_get_ant_get = *Hamlibc::rig_caps_get_ant_get;
*swig_get_ant_set = *Hamlibc::rig_caps_get_ant_set;
*swig_set_level_get = *Hamlibc::rig_caps_set_level_get;
*swig_set_level_set = *Hamlibc::rig_caps_set_level_set;
*swig_get_level_get = *Hamlibc::rig_caps_get_level_get;
*swig_get_level_set = *Hamlibc::rig_caps_get_level_set;
*swig_set_func_get = *Hamlibc::rig_caps_set_func_get;
*swig_set_func_set = *Hamlibc::rig_caps_set_func_set;
*swig_get_func_get = *Hamlibc::rig_caps_get_func_get;
*swig_get_func_set = *Hamlibc::rig_caps_get_func_set;
*swig_set_parm_get = *Hamlibc::rig_caps_set_parm_get;
*swig_set_parm_set = *Hamlibc::rig_caps_set_parm_set;
*swig_get_parm_get = *Hamlibc::rig_caps_get_parm_get;
*swig_get_parm_set = *Hamlibc::rig_caps_get_parm_set;
*swig_set_ext_level_get = *Hamlibc::rig_caps_set_ext_level_get;
*swig_set_ext_level_set = *Hamlibc::rig_caps_set_ext_level_set;
*swig_get_ext_level_get = *Hamlibc::rig_caps_get_ext_level_get;
*swig_get_ext_level_set = *Hamlibc::rig_caps_get_ext_level_set;
*swig_set_ext_parm_get = *Hamlibc::rig_caps_set_ext_parm_get;
*swig_set_ext_parm_set = *Hamlibc::rig_caps_set_ext_parm_set;
*swig_get_ext_parm_get = *Hamlibc::rig_caps_get_ext_parm_get;
*swig_get_ext_parm_set = *Hamlibc::rig_caps_get_ext_parm_set;
*swig_set_conf_get = *Hamlibc::rig_caps_set_conf_get;
*swig_set_conf_set = *Hamlibc::rig_caps_set_conf_set;
*swig_get_conf_get = *Hamlibc::rig_caps_get_conf_get;
*swig_get_conf_set = *Hamlibc::rig_caps_get_conf_set;
*swig_send_dtmf_get = *Hamlibc::rig_caps_send_dtmf_get;
*swig_send_dtmf_set = *Hamlibc::rig_caps_send_dtmf_set;
*swig_recv_dtmf_get = *Hamlibc::rig_caps_recv_dtmf_get;
*swig_recv_dtmf_set = *Hamlibc::rig_caps_recv_dtmf_set;
*swig_send_morse_get = *Hamlibc::rig_caps_send_morse_get;
*swig_send_morse_set = *Hamlibc::rig_caps_send_morse_set;
*swig_set_bank_get = *Hamlibc::rig_caps_set_bank_get;
*swig_set_bank_set = *Hamlibc::rig_caps_set_bank_set;
*swig_set_mem_get = *Hamlibc::rig_caps_set_mem_get;
*swig_set_mem_set = *Hamlibc::rig_caps_set_mem_set;
*swig_get_mem_get = *Hamlibc::rig_caps_get_mem_get;
*swig_get_mem_set = *Hamlibc::rig_caps_get_mem_set;
*swig_vfo_op_get = *Hamlibc::rig_caps_vfo_op_get;
*swig_vfo_op_set = *Hamlibc::rig_caps_vfo_op_set;
*swig_scan_get = *Hamlibc::rig_caps_scan_get;
*swig_scan_set = *Hamlibc::rig_caps_scan_set;
*swig_set_trn_get = *Hamlibc::rig_caps_set_trn_get;
*swig_set_trn_set = *Hamlibc::rig_caps_set_trn_set;
*swig_get_trn_get = *Hamlibc::rig_caps_get_trn_get;
*swig_get_trn_set = *Hamlibc::rig_caps_get_trn_set;
*swig_decode_event_get = *Hamlibc::rig_caps_decode_event_get;
*swig_decode_event_set = *Hamlibc::rig_caps_decode_event_set;
*swig_set_channel_get = *Hamlibc::rig_caps_set_channel_get;
*swig_set_channel_set = *Hamlibc::rig_caps_set_channel_set;
*swig_get_channel_get = *Hamlibc::rig_caps_get_channel_get;
*swig_get_channel_set = *Hamlibc::rig_caps_get_channel_set;
*swig_get_info_get = *Hamlibc::rig_caps_get_info_get;
*swig_get_info_set = *Hamlibc::rig_caps_get_info_set;
*swig_set_chan_all_cb_get = *Hamlibc::rig_caps_set_chan_all_cb_get;
*swig_set_chan_all_cb_set = *Hamlibc::rig_caps_set_chan_all_cb_set;
*swig_get_chan_all_cb_get = *Hamlibc::rig_caps_get_chan_all_cb_get;
*swig_get_chan_all_cb_set = *Hamlibc::rig_caps_get_chan_all_cb_set;
*swig_set_mem_all_cb_get = *Hamlibc::rig_caps_set_mem_all_cb_get;
*swig_set_mem_all_cb_set = *Hamlibc::rig_caps_set_mem_all_cb_set;
*swig_get_mem_all_cb_get = *Hamlibc::rig_caps_get_mem_all_cb_get;
*swig_get_mem_all_cb_set = *Hamlibc::rig_caps_get_mem_all_cb_set;
*swig_clone_combo_set_get = *Hamlibc::rig_caps_clone_combo_set_get;
*swig_clone_combo_set_set = *Hamlibc::rig_caps_clone_combo_set_set;
*swig_clone_combo_get_get = *Hamlibc::rig_caps_clone_combo_get_get;
*swig_clone_combo_get_set = *Hamlibc::rig_caps_clone_combo_get_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_rig_caps(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_rig_caps($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::hamlib_port_t ##############

package Hamlib::hamlib_port_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_fd_get = *Hamlibc::hamlib_port_t_fd_get;
*swig_fd_set = *Hamlibc::hamlib_port_t_fd_set;
*swig_handle_get = *Hamlibc::hamlib_port_t_handle_get;
*swig_handle_set = *Hamlibc::hamlib_port_t_handle_set;
*swig_write_delay_get = *Hamlibc::hamlib_port_t_write_delay_get;
*swig_write_delay_set = *Hamlibc::hamlib_port_t_write_delay_set;
*swig_post_write_delay_get = *Hamlibc::hamlib_port_t_post_write_delay_get;
*swig_post_write_delay_set = *Hamlibc::hamlib_port_t_post_write_delay_set;
*swig_timeout_get = *Hamlibc::hamlib_port_t_timeout_get;
*swig_timeout_set = *Hamlibc::hamlib_port_t_timeout_set;
*swig_retry_get = *Hamlibc::hamlib_port_t_retry_get;
*swig_retry_set = *Hamlibc::hamlib_port_t_retry_set;
*swig_pathname_get = *Hamlibc::hamlib_port_t_pathname_get;
*swig_pathname_set = *Hamlibc::hamlib_port_t_pathname_set;
*swig_parm_get = *Hamlibc::hamlib_port_t_parm_get;
*swig_parm_set = *Hamlibc::hamlib_port_t_parm_set;
*swig_post_write_date_get = *Hamlibc::hamlib_port_t_post_write_date_get;
*swig_post_write_date_set = *Hamlibc::hamlib_port_t_post_write_date_set;
*swig_type_get = *Hamlibc::hamlib_port_t_type_get;
*swig_type_set = *Hamlibc::hamlib_port_t_type_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_hamlib_port_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_hamlib_port_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::hamlib_port_t_parm ##############

package Hamlib::hamlib_port_t_parm;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_usb_get = *Hamlibc::hamlib_port_t_parm_usb_get;
*swig_usb_set = *Hamlibc::hamlib_port_t_parm_usb_set;
*swig_parallel_get = *Hamlibc::hamlib_port_t_parm_parallel_get;
*swig_parallel_set = *Hamlibc::hamlib_port_t_parm_parallel_set;
*swig_serial_get = *Hamlibc::hamlib_port_t_parm_serial_get;
*swig_serial_set = *Hamlibc::hamlib_port_t_parm_serial_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_hamlib_port_t_parm(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_hamlib_port_t_parm($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::hamlib_port_t_parm_usb ##############

package Hamlib::hamlib_port_t_parm_usb;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_vid_get = *Hamlibc::hamlib_port_t_parm_usb_vid_get;
*swig_vid_set = *Hamlibc::hamlib_port_t_parm_usb_vid_set;
*swig_pid_get = *Hamlibc::hamlib_port_t_parm_usb_pid_get;
*swig_pid_set = *Hamlibc::hamlib_port_t_parm_usb_pid_set;
*swig_conf_get = *Hamlibc::hamlib_port_t_parm_usb_conf_get;
*swig_conf_set = *Hamlibc::hamlib_port_t_parm_usb_conf_set;
*swig_iface_get = *Hamlibc::hamlib_port_t_parm_usb_iface_get;
*swig_iface_set = *Hamlibc::hamlib_port_t_parm_usb_iface_set;
*swig_alt_get = *Hamlibc::hamlib_port_t_parm_usb_alt_get;
*swig_alt_set = *Hamlibc::hamlib_port_t_parm_usb_alt_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_hamlib_port_t_parm_usb(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_hamlib_port_t_parm_usb($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::hamlib_port_t_parm_parallel ##############

package Hamlib::hamlib_port_t_parm_parallel;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_pin_get = *Hamlibc::hamlib_port_t_parm_parallel_pin_get;
*swig_pin_set = *Hamlibc::hamlib_port_t_parm_parallel_pin_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_hamlib_port_t_parm_parallel(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_hamlib_port_t_parm_parallel($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::hamlib_port_t_parm_serial ##############

package Hamlib::hamlib_port_t_parm_serial;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_rate_get = *Hamlibc::hamlib_port_t_parm_serial_rate_get;
*swig_rate_set = *Hamlibc::hamlib_port_t_parm_serial_rate_set;
*swig_data_bits_get = *Hamlibc::hamlib_port_t_parm_serial_data_bits_get;
*swig_data_bits_set = *Hamlibc::hamlib_port_t_parm_serial_data_bits_set;
*swig_stop_bits_get = *Hamlibc::hamlib_port_t_parm_serial_stop_bits_get;
*swig_stop_bits_set = *Hamlibc::hamlib_port_t_parm_serial_stop_bits_set;
*swig_parity_get = *Hamlibc::hamlib_port_t_parm_serial_parity_get;
*swig_parity_set = *Hamlibc::hamlib_port_t_parm_serial_parity_set;
*swig_handshake_get = *Hamlibc::hamlib_port_t_parm_serial_handshake_get;
*swig_handshake_set = *Hamlibc::hamlib_port_t_parm_serial_handshake_set;
*swig_rts_state_get = *Hamlibc::hamlib_port_t_parm_serial_rts_state_get;
*swig_rts_state_set = *Hamlibc::hamlib_port_t_parm_serial_rts_state_set;
*swig_dtr_state_get = *Hamlibc::hamlib_port_t_parm_serial_dtr_state_get;
*swig_dtr_state_set = *Hamlibc::hamlib_port_t_parm_serial_dtr_state_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_hamlib_port_t_parm_serial(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_hamlib_port_t_parm_serial($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::hamlib_port_t_post_write_date ##############

package Hamlib::hamlib_port_t_post_write_date;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_tv_sec_get = *Hamlibc::hamlib_port_t_post_write_date_tv_sec_get;
*swig_tv_sec_set = *Hamlibc::hamlib_port_t_post_write_date_tv_sec_set;
*swig_tv_usec_get = *Hamlibc::hamlib_port_t_post_write_date_tv_usec_get;
*swig_tv_usec_set = *Hamlibc::hamlib_port_t_post_write_date_tv_usec_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_hamlib_port_t_post_write_date(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_hamlib_port_t_post_write_date($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::hamlib_port_t_type ##############

package Hamlib::hamlib_port_t_type;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_rig_get = *Hamlibc::hamlib_port_t_type_rig_get;
*swig_rig_set = *Hamlibc::hamlib_port_t_type_rig_set;
*swig_ptt_get = *Hamlibc::hamlib_port_t_type_ptt_get;
*swig_ptt_set = *Hamlibc::hamlib_port_t_type_ptt_set;
*swig_dcd_get = *Hamlibc::hamlib_port_t_type_dcd_get;
*swig_dcd_set = *Hamlibc::hamlib_port_t_type_dcd_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_hamlib_port_t_type(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_hamlib_port_t_type($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::rig_state ##############

package Hamlib::rig_state;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_rigport_get = *Hamlibc::rig_state_rigport_get;
*swig_rigport_set = *Hamlibc::rig_state_rigport_set;
*swig_pttport_get = *Hamlibc::rig_state_pttport_get;
*swig_pttport_set = *Hamlibc::rig_state_pttport_set;
*swig_dcdport_get = *Hamlibc::rig_state_dcdport_get;
*swig_dcdport_set = *Hamlibc::rig_state_dcdport_set;
*swig_vfo_comp_get = *Hamlibc::rig_state_vfo_comp_get;
*swig_vfo_comp_set = *Hamlibc::rig_state_vfo_comp_set;
*swig_itu_region_get = *Hamlibc::rig_state_itu_region_get;
*swig_itu_region_set = *Hamlibc::rig_state_itu_region_set;
*swig_rx_range_list_get = *Hamlibc::rig_state_rx_range_list_get;
*swig_rx_range_list_set = *Hamlibc::rig_state_rx_range_list_set;
*swig_tx_range_list_get = *Hamlibc::rig_state_tx_range_list_get;
*swig_tx_range_list_set = *Hamlibc::rig_state_tx_range_list_set;
*swig_tuning_steps_get = *Hamlibc::rig_state_tuning_steps_get;
*swig_tuning_steps_set = *Hamlibc::rig_state_tuning_steps_set;
*swig_filters_get = *Hamlibc::rig_state_filters_get;
*swig_filters_set = *Hamlibc::rig_state_filters_set;
*swig_str_cal_get = *Hamlibc::rig_state_str_cal_get;
*swig_str_cal_set = *Hamlibc::rig_state_str_cal_set;
*swig_chan_list_get = *Hamlibc::rig_state_chan_list_get;
*swig_chan_list_set = *Hamlibc::rig_state_chan_list_set;
*swig_max_rit_get = *Hamlibc::rig_state_max_rit_get;
*swig_max_rit_set = *Hamlibc::rig_state_max_rit_set;
*swig_max_xit_get = *Hamlibc::rig_state_max_xit_get;
*swig_max_xit_set = *Hamlibc::rig_state_max_xit_set;
*swig_max_ifshift_get = *Hamlibc::rig_state_max_ifshift_get;
*swig_max_ifshift_set = *Hamlibc::rig_state_max_ifshift_set;
*swig_announces_get = *Hamlibc::rig_state_announces_get;
*swig_announces_set = *Hamlibc::rig_state_announces_set;
*swig_preamp_get = *Hamlibc::rig_state_preamp_get;
*swig_preamp_set = *Hamlibc::rig_state_preamp_set;
*swig_attenuator_get = *Hamlibc::rig_state_attenuator_get;
*swig_attenuator_set = *Hamlibc::rig_state_attenuator_set;
*swig_has_get_func_get = *Hamlibc::rig_state_has_get_func_get;
*swig_has_get_func_set = *Hamlibc::rig_state_has_get_func_set;
*swig_has_set_func_get = *Hamlibc::rig_state_has_set_func_get;
*swig_has_set_func_set = *Hamlibc::rig_state_has_set_func_set;
*swig_has_get_level_get = *Hamlibc::rig_state_has_get_level_get;
*swig_has_get_level_set = *Hamlibc::rig_state_has_get_level_set;
*swig_has_set_level_get = *Hamlibc::rig_state_has_set_level_get;
*swig_has_set_level_set = *Hamlibc::rig_state_has_set_level_set;
*swig_has_get_parm_get = *Hamlibc::rig_state_has_get_parm_get;
*swig_has_get_parm_set = *Hamlibc::rig_state_has_get_parm_set;
*swig_has_set_parm_get = *Hamlibc::rig_state_has_set_parm_get;
*swig_has_set_parm_set = *Hamlibc::rig_state_has_set_parm_set;
*swig_level_gran_get = *Hamlibc::rig_state_level_gran_get;
*swig_level_gran_set = *Hamlibc::rig_state_level_gran_set;
*swig_parm_gran_get = *Hamlibc::rig_state_parm_gran_get;
*swig_parm_gran_set = *Hamlibc::rig_state_parm_gran_set;
*swig_hold_decode_get = *Hamlibc::rig_state_hold_decode_get;
*swig_hold_decode_set = *Hamlibc::rig_state_hold_decode_set;
*swig_current_vfo_get = *Hamlibc::rig_state_current_vfo_get;
*swig_current_vfo_set = *Hamlibc::rig_state_current_vfo_set;
*swig_vfo_list_get = *Hamlibc::rig_state_vfo_list_get;
*swig_vfo_list_set = *Hamlibc::rig_state_vfo_list_set;
*swig_comm_state_get = *Hamlibc::rig_state_comm_state_get;
*swig_comm_state_set = *Hamlibc::rig_state_comm_state_set;
*swig_priv_get = *Hamlibc::rig_state_priv_get;
*swig_priv_set = *Hamlibc::rig_state_priv_set;
*swig_obj_get = *Hamlibc::rig_state_obj_get;
*swig_obj_set = *Hamlibc::rig_state_obj_set;
*swig_transceive_get = *Hamlibc::rig_state_transceive_get;
*swig_transceive_set = *Hamlibc::rig_state_transceive_set;
*swig_poll_interval_get = *Hamlibc::rig_state_poll_interval_get;
*swig_poll_interval_set = *Hamlibc::rig_state_poll_interval_set;
*swig_current_freq_get = *Hamlibc::rig_state_current_freq_get;
*swig_current_freq_set = *Hamlibc::rig_state_current_freq_set;
*swig_current_mode_get = *Hamlibc::rig_state_current_mode_get;
*swig_current_mode_set = *Hamlibc::rig_state_current_mode_set;
*swig_current_width_get = *Hamlibc::rig_state_current_width_get;
*swig_current_width_set = *Hamlibc::rig_state_current_width_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_rig_state(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_rig_state($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::rig_callbacks ##############

package Hamlib::rig_callbacks;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_freq_event_get = *Hamlibc::rig_callbacks_freq_event_get;
*swig_freq_event_set = *Hamlibc::rig_callbacks_freq_event_set;
*swig_freq_arg_get = *Hamlibc::rig_callbacks_freq_arg_get;
*swig_freq_arg_set = *Hamlibc::rig_callbacks_freq_arg_set;
*swig_mode_event_get = *Hamlibc::rig_callbacks_mode_event_get;
*swig_mode_event_set = *Hamlibc::rig_callbacks_mode_event_set;
*swig_mode_arg_get = *Hamlibc::rig_callbacks_mode_arg_get;
*swig_mode_arg_set = *Hamlibc::rig_callbacks_mode_arg_set;
*swig_vfo_event_get = *Hamlibc::rig_callbacks_vfo_event_get;
*swig_vfo_event_set = *Hamlibc::rig_callbacks_vfo_event_set;
*swig_vfo_arg_get = *Hamlibc::rig_callbacks_vfo_arg_get;
*swig_vfo_arg_set = *Hamlibc::rig_callbacks_vfo_arg_set;
*swig_ptt_event_get = *Hamlibc::rig_callbacks_ptt_event_get;
*swig_ptt_event_set = *Hamlibc::rig_callbacks_ptt_event_set;
*swig_ptt_arg_get = *Hamlibc::rig_callbacks_ptt_arg_get;
*swig_ptt_arg_set = *Hamlibc::rig_callbacks_ptt_arg_set;
*swig_dcd_event_get = *Hamlibc::rig_callbacks_dcd_event_get;
*swig_dcd_event_set = *Hamlibc::rig_callbacks_dcd_event_set;
*swig_dcd_arg_get = *Hamlibc::rig_callbacks_dcd_arg_get;
*swig_dcd_arg_set = *Hamlibc::rig_callbacks_dcd_arg_set;
*swig_pltune_get = *Hamlibc::rig_callbacks_pltune_get;
*swig_pltune_set = *Hamlibc::rig_callbacks_pltune_set;
*swig_pltune_arg_get = *Hamlibc::rig_callbacks_pltune_arg_get;
*swig_pltune_arg_set = *Hamlibc::rig_callbacks_pltune_arg_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_rig_callbacks(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_rig_callbacks($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::rig ##############

package Hamlib::rig;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_caps_get = *Hamlibc::rig_caps_get;
*swig_caps_set = *Hamlibc::rig_caps_set;
*swig_state_get = *Hamlibc::rig_state_get;
*swig_state_set = *Hamlibc::rig_state_set;
*swig_callbacks_get = *Hamlibc::rig_callbacks_get;
*swig_callbacks_set = *Hamlibc::rig_callbacks_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_rig(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_rig($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::rot_caps ##############

package Hamlib::rot_caps;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_rot_model_get = *Hamlibc::rot_caps_rot_model_get;
*swig_rot_model_set = *Hamlibc::rot_caps_rot_model_set;
*swig_model_name_get = *Hamlibc::rot_caps_model_name_get;
*swig_model_name_set = *Hamlibc::rot_caps_model_name_set;
*swig_mfg_name_get = *Hamlibc::rot_caps_mfg_name_get;
*swig_mfg_name_set = *Hamlibc::rot_caps_mfg_name_set;
*swig_version_get = *Hamlibc::rot_caps_version_get;
*swig_version_set = *Hamlibc::rot_caps_version_set;
*swig_copyright_get = *Hamlibc::rot_caps_copyright_get;
*swig_copyright_set = *Hamlibc::rot_caps_copyright_set;
*swig_status_get = *Hamlibc::rot_caps_status_get;
*swig_status_set = *Hamlibc::rot_caps_status_set;
*swig_rot_type_get = *Hamlibc::rot_caps_rot_type_get;
*swig_rot_type_set = *Hamlibc::rot_caps_rot_type_set;
*swig_port_type_get = *Hamlibc::rot_caps_port_type_get;
*swig_port_type_set = *Hamlibc::rot_caps_port_type_set;
*swig_serial_rate_min_get = *Hamlibc::rot_caps_serial_rate_min_get;
*swig_serial_rate_min_set = *Hamlibc::rot_caps_serial_rate_min_set;
*swig_serial_rate_max_get = *Hamlibc::rot_caps_serial_rate_max_get;
*swig_serial_rate_max_set = *Hamlibc::rot_caps_serial_rate_max_set;
*swig_serial_data_bits_get = *Hamlibc::rot_caps_serial_data_bits_get;
*swig_serial_data_bits_set = *Hamlibc::rot_caps_serial_data_bits_set;
*swig_serial_stop_bits_get = *Hamlibc::rot_caps_serial_stop_bits_get;
*swig_serial_stop_bits_set = *Hamlibc::rot_caps_serial_stop_bits_set;
*swig_serial_parity_get = *Hamlibc::rot_caps_serial_parity_get;
*swig_serial_parity_set = *Hamlibc::rot_caps_serial_parity_set;
*swig_serial_handshake_get = *Hamlibc::rot_caps_serial_handshake_get;
*swig_serial_handshake_set = *Hamlibc::rot_caps_serial_handshake_set;
*swig_write_delay_get = *Hamlibc::rot_caps_write_delay_get;
*swig_write_delay_set = *Hamlibc::rot_caps_write_delay_set;
*swig_post_write_delay_get = *Hamlibc::rot_caps_post_write_delay_get;
*swig_post_write_delay_set = *Hamlibc::rot_caps_post_write_delay_set;
*swig_timeout_get = *Hamlibc::rot_caps_timeout_get;
*swig_timeout_set = *Hamlibc::rot_caps_timeout_set;
*swig_retry_get = *Hamlibc::rot_caps_retry_get;
*swig_retry_set = *Hamlibc::rot_caps_retry_set;
*swig_min_az_get = *Hamlibc::rot_caps_min_az_get;
*swig_min_az_set = *Hamlibc::rot_caps_min_az_set;
*swig_max_az_get = *Hamlibc::rot_caps_max_az_get;
*swig_max_az_set = *Hamlibc::rot_caps_max_az_set;
*swig_min_el_get = *Hamlibc::rot_caps_min_el_get;
*swig_min_el_set = *Hamlibc::rot_caps_min_el_set;
*swig_max_el_get = *Hamlibc::rot_caps_max_el_get;
*swig_max_el_set = *Hamlibc::rot_caps_max_el_set;
*swig_cfgparams_get = *Hamlibc::rot_caps_cfgparams_get;
*swig_cfgparams_set = *Hamlibc::rot_caps_cfgparams_set;
*swig_priv_get = *Hamlibc::rot_caps_priv_get;
*swig_priv_set = *Hamlibc::rot_caps_priv_set;
*swig_rot_init_get = *Hamlibc::rot_caps_rot_init_get;
*swig_rot_init_set = *Hamlibc::rot_caps_rot_init_set;
*swig_set_conf_get = *Hamlibc::rot_caps_set_conf_get;
*swig_set_conf_set = *Hamlibc::rot_caps_set_conf_set;
*swig_get_conf_get = *Hamlibc::rot_caps_get_conf_get;
*swig_get_conf_set = *Hamlibc::rot_caps_get_conf_set;
*swig_set_position_get = *Hamlibc::rot_caps_set_position_get;
*swig_set_position_set = *Hamlibc::rot_caps_set_position_set;
*swig_get_position_get = *Hamlibc::rot_caps_get_position_get;
*swig_get_position_set = *Hamlibc::rot_caps_get_position_set;
*swig_stop_get = *Hamlibc::rot_caps_stop_get;
*swig_stop_set = *Hamlibc::rot_caps_stop_set;
*swig_park_get = *Hamlibc::rot_caps_park_get;
*swig_park_set = *Hamlibc::rot_caps_park_set;
*swig_reset_get = *Hamlibc::rot_caps_reset_get;
*swig_reset_set = *Hamlibc::rot_caps_reset_set;
*swig_move_get = *Hamlibc::rot_caps_move_get;
*swig_move_set = *Hamlibc::rot_caps_move_set;
*swig_get_info_get = *Hamlibc::rot_caps_get_info_get;
*swig_get_info_set = *Hamlibc::rot_caps_get_info_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_rot_caps(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_rot_caps($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::rot_state ##############

package Hamlib::rot_state;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_min_az_get = *Hamlibc::rot_state_min_az_get;
*swig_min_az_set = *Hamlibc::rot_state_min_az_set;
*swig_max_az_get = *Hamlibc::rot_state_max_az_get;
*swig_max_az_set = *Hamlibc::rot_state_max_az_set;
*swig_min_el_get = *Hamlibc::rot_state_min_el_get;
*swig_min_el_set = *Hamlibc::rot_state_min_el_set;
*swig_max_el_get = *Hamlibc::rot_state_max_el_get;
*swig_max_el_set = *Hamlibc::rot_state_max_el_set;
*swig_rotport_get = *Hamlibc::rot_state_rotport_get;
*swig_rotport_set = *Hamlibc::rot_state_rotport_set;
*swig_comm_state_get = *Hamlibc::rot_state_comm_state_get;
*swig_comm_state_set = *Hamlibc::rot_state_comm_state_set;
*swig_priv_get = *Hamlibc::rot_state_priv_get;
*swig_priv_set = *Hamlibc::rot_state_priv_set;
*swig_obj_get = *Hamlibc::rot_state_obj_get;
*swig_obj_set = *Hamlibc::rot_state_obj_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_rot_state(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_rot_state($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::rot ##############

package Hamlib::rot;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_caps_get = *Hamlibc::rot_caps_get;
*swig_caps_set = *Hamlibc::rot_caps_set;
*swig_state_get = *Hamlibc::rot_state_get;
*swig_state_set = *Hamlibc::rot_state_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_rot(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_rot($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::Rig ##############

package Hamlib::Rig;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_rig_get = *Hamlibc::Rig_rig_get;
*swig_rig_set = *Hamlibc::Rig_rig_set;
*swig_caps_get = *Hamlibc::Rig_caps_get;
*swig_caps_set = *Hamlibc::Rig_caps_set;
*swig_state_get = *Hamlibc::Rig_state_get;
*swig_state_set = *Hamlibc::Rig_state_set;
*swig_error_status_get = *Hamlibc::Rig_error_status_get;
*swig_error_status_set = *Hamlibc::Rig_error_status_set;
*swig_do_exception_get = *Hamlibc::Rig_do_exception_get;
*swig_do_exception_set = *Hamlibc::Rig_do_exception_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_Rig(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_Rig($self);
        delete $OWNER{$self};
    }
}

*open = *Hamlibc::Rig_open;
*close = *Hamlibc::Rig_close;
*set_freq = *Hamlibc::Rig_set_freq;
*set_mode = *Hamlibc::Rig_set_mode;
*set_ptt = *Hamlibc::Rig_set_ptt;
*set_rptr_shift = *Hamlibc::Rig_set_rptr_shift;
*set_rptr_offs = *Hamlibc::Rig_set_rptr_offs;
*set_ctcss_tone = *Hamlibc::Rig_set_ctcss_tone;
*set_dcs_code = *Hamlibc::Rig_set_dcs_code;
*set_ctcss_sql = *Hamlibc::Rig_set_ctcss_sql;
*set_dcs_sql = *Hamlibc::Rig_set_dcs_sql;
*set_split_freq = *Hamlibc::Rig_set_split_freq;
*set_split_mode = *Hamlibc::Rig_set_split_mode;
*set_split_vfo = *Hamlibc::Rig_set_split_vfo;
*set_rit = *Hamlibc::Rig_set_rit;
*set_xit = *Hamlibc::Rig_set_xit;
*set_ts = *Hamlibc::Rig_set_ts;
*set_ant = *Hamlibc::Rig_set_ant;
*set_func = *Hamlibc::Rig_set_func;
*set_bank = *Hamlibc::Rig_set_bank;
*set_mem = *Hamlibc::Rig_set_mem;
*send_dtmf = *Hamlibc::Rig_send_dtmf;
*send_morse = *Hamlibc::Rig_send_morse;
*vfo_op = *Hamlibc::Rig_vfo_op;
*scan = *Hamlibc::Rig_scan;
*set_level = *Hamlibc::Rig_set_level;
*set_ext_level = *Hamlibc::Rig_set_ext_level;
*get_level_i = *Hamlibc::Rig_get_level_i;
*get_level_f = *Hamlibc::Rig_get_level_f;
*set_vfo = *Hamlibc::Rig_set_vfo;
*set_powerstat = *Hamlibc::Rig_set_powerstat;
*set_trn = *Hamlibc::Rig_set_trn;
*has_set_level = *Hamlibc::Rig_has_set_level;
*has_set_parm = *Hamlibc::Rig_has_set_parm;
*has_set_func = *Hamlibc::Rig_has_set_func;
*reset = *Hamlibc::Rig_reset;
*has_scan = *Hamlibc::Rig_has_scan;
*has_vfo_op = *Hamlibc::Rig_has_vfo_op;
*passband_normal = *Hamlibc::Rig_passband_normal;
*passband_narrow = *Hamlibc::Rig_passband_narrow;
*passband_wide = *Hamlibc::Rig_passband_wide;
*ext_token_lookup = *Hamlibc::Rig_ext_token_lookup;
*token_lookup = *Hamlibc::Rig_token_lookup;
*set_ext_parm = *Hamlibc::Rig_set_ext_parm;
*set_parm = *Hamlibc::Rig_set_parm;
*get_parm_i = *Hamlibc::Rig_get_parm_i;
*get_parm_f = *Hamlibc::Rig_get_parm_f;
*get_parm = *Hamlibc::Rig_get_parm;
*set_conf = *Hamlibc::Rig_set_conf;
*get_freq = *Hamlibc::Rig_get_freq;
*get_mode = *Hamlibc::Rig_get_mode;
*get_split_mode = *Hamlibc::Rig_get_split_mode;
*get_vfo = *Hamlibc::Rig_get_vfo;
*get_ptt = *Hamlibc::Rig_get_ptt;
*get_rptr_shift = *Hamlibc::Rig_get_rptr_shift;
*get_rptr_offs = *Hamlibc::Rig_get_rptr_offs;
*get_ctcss_tone = *Hamlibc::Rig_get_ctcss_tone;
*get_dcs_code = *Hamlibc::Rig_get_dcs_code;
*get_ctcss_sql = *Hamlibc::Rig_get_ctcss_sql;
*get_dcs_sql = *Hamlibc::Rig_get_dcs_sql;
*get_split_freq = *Hamlibc::Rig_get_split_freq;
*get_split_vfo = *Hamlibc::Rig_get_split_vfo;
*get_rit = *Hamlibc::Rig_get_rit;
*get_xit = *Hamlibc::Rig_get_xit;
*get_ts = *Hamlibc::Rig_get_ts;
*get_ant = *Hamlibc::Rig_get_ant;
*get_mem = *Hamlibc::Rig_get_mem;
*get_powerstat = *Hamlibc::Rig_get_powerstat;
*get_trn = *Hamlibc::Rig_get_trn;
*mem_count = *Hamlibc::Rig_mem_count;
*lookup_mem_caps = *Hamlibc::Rig_lookup_mem_caps;
*set_channel = *Hamlibc::Rig_set_channel;
*chan_clear = *Hamlibc::Rig_chan_clear;
*get_chan_all = *Hamlibc::Rig_get_chan_all;
*get_channel = *Hamlibc::Rig_get_channel;
*get_conf = *Hamlibc::Rig_get_conf;
*recv_dtmf = *Hamlibc::Rig_recv_dtmf;
*get_info = *Hamlibc::Rig_get_info;
*get_func = *Hamlibc::Rig_get_func;
*get_level = *Hamlibc::Rig_get_level;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::channelArray ##############

package Hamlib::channelArray;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_channelArray(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_channelArray($self);
        delete $OWNER{$self};
    }
}

*getitem = *Hamlibc::channelArray_getitem;
*setitem = *Hamlibc::channelArray_setitem;
*cast = *Hamlibc::channelArray_cast;
*frompointer = *Hamlibc::channelArray_frompointer;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::toneArray ##############

package Hamlib::toneArray;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_toneArray(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_toneArray($self);
        delete $OWNER{$self};
    }
}

*getitem = *Hamlibc::toneArray_getitem;
*setitem = *Hamlibc::toneArray_setitem;
*cast = *Hamlibc::toneArray_cast;
*frompointer = *Hamlibc::toneArray_frompointer;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Hamlib::Rot ##############

package Hamlib::Rot;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Hamlib );
%OWNER = ();
%ITERATORS = ();
*swig_rot_get = *Hamlibc::Rot_rot_get;
*swig_rot_set = *Hamlibc::Rot_rot_set;
*swig_caps_get = *Hamlibc::Rot_caps_get;
*swig_caps_set = *Hamlibc::Rot_caps_set;
*swig_state_get = *Hamlibc::Rot_state_get;
*swig_state_set = *Hamlibc::Rot_state_set;
*swig_error_status_get = *Hamlibc::Rot_error_status_get;
*swig_error_status_set = *Hamlibc::Rot_error_status_set;
*swig_do_exception_get = *Hamlibc::Rot_do_exception_get;
*swig_do_exception_set = *Hamlibc::Rot_do_exception_set;
sub new {
    my $pkg = shift;
    my $self = Hamlibc::new_Rot(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Hamlibc::delete_Rot($self);
        delete $OWNER{$self};
    }
}

*open = *Hamlibc::Rot_open;
*close = *Hamlibc::Rot_close;
*set_position = *Hamlibc::Rot_set_position;
*get_position = *Hamlibc::Rot_get_position;
*stop = *Hamlibc::Rot_stop;
*park = *Hamlibc::Rot_park;
*reset = *Hamlibc::Rot_reset;
*move = *Hamlibc::Rot_move;
*token_lookup = *Hamlibc::Rot_token_lookup;
*set_conf = *Hamlibc::Rot_set_conf;
*get_conf = *Hamlibc::Rot_get_conf;
*get_info = *Hamlibc::Rot_get_info;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package Hamlib;

*RIG_MODEL_NONE = *Hamlibc::RIG_MODEL_NONE;
*RIG_MODEL_DUMMY = *Hamlibc::RIG_MODEL_DUMMY;
*RIG_MODEL_NETRIGCTL = *Hamlibc::RIG_MODEL_NETRIGCTL;
*RIG_MODEL_FT847 = *Hamlibc::RIG_MODEL_FT847;
*RIG_MODEL_FT1000 = *Hamlibc::RIG_MODEL_FT1000;
*RIG_MODEL_FT1000D = *Hamlibc::RIG_MODEL_FT1000D;
*RIG_MODEL_FT1000MPMKV = *Hamlibc::RIG_MODEL_FT1000MPMKV;
*RIG_MODEL_FT747 = *Hamlibc::RIG_MODEL_FT747;
*RIG_MODEL_FT757 = *Hamlibc::RIG_MODEL_FT757;
*RIG_MODEL_FT757GXII = *Hamlibc::RIG_MODEL_FT757GXII;
*RIG_MODEL_FT575 = *Hamlibc::RIG_MODEL_FT575;
*RIG_MODEL_FT767 = *Hamlibc::RIG_MODEL_FT767;
*RIG_MODEL_FT736R = *Hamlibc::RIG_MODEL_FT736R;
*RIG_MODEL_FT840 = *Hamlibc::RIG_MODEL_FT840;
*RIG_MODEL_FT820 = *Hamlibc::RIG_MODEL_FT820;
*RIG_MODEL_FT900 = *Hamlibc::RIG_MODEL_FT900;
*RIG_MODEL_FT920 = *Hamlibc::RIG_MODEL_FT920;
*RIG_MODEL_FT890 = *Hamlibc::RIG_MODEL_FT890;
*RIG_MODEL_FT990 = *Hamlibc::RIG_MODEL_FT990;
*RIG_MODEL_FRG100 = *Hamlibc::RIG_MODEL_FRG100;
*RIG_MODEL_FRG9600 = *Hamlibc::RIG_MODEL_FRG9600;
*RIG_MODEL_FRG8800 = *Hamlibc::RIG_MODEL_FRG8800;
*RIG_MODEL_FT817 = *Hamlibc::RIG_MODEL_FT817;
*RIG_MODEL_FT100 = *Hamlibc::RIG_MODEL_FT100;
*RIG_MODEL_FT857 = *Hamlibc::RIG_MODEL_FT857;
*RIG_MODEL_FT897 = *Hamlibc::RIG_MODEL_FT897;
*RIG_MODEL_FT1000MP = *Hamlibc::RIG_MODEL_FT1000MP;
*RIG_MODEL_FT1000MPMKVFLD = *Hamlibc::RIG_MODEL_FT1000MPMKVFLD;
*RIG_MODEL_VR5000 = *Hamlibc::RIG_MODEL_VR5000;
*RIG_MODEL_FT450 = *Hamlibc::RIG_MODEL_FT450;
*RIG_MODEL_FT950 = *Hamlibc::RIG_MODEL_FT950;
*RIG_MODEL_TS50 = *Hamlibc::RIG_MODEL_TS50;
*RIG_MODEL_TS440 = *Hamlibc::RIG_MODEL_TS440;
*RIG_MODEL_TS450S = *Hamlibc::RIG_MODEL_TS450S;
*RIG_MODEL_TS570D = *Hamlibc::RIG_MODEL_TS570D;
*RIG_MODEL_TS690S = *Hamlibc::RIG_MODEL_TS690S;
*RIG_MODEL_TS711 = *Hamlibc::RIG_MODEL_TS711;
*RIG_MODEL_TS790 = *Hamlibc::RIG_MODEL_TS790;
*RIG_MODEL_TS811 = *Hamlibc::RIG_MODEL_TS811;
*RIG_MODEL_TS850 = *Hamlibc::RIG_MODEL_TS850;
*RIG_MODEL_TS870S = *Hamlibc::RIG_MODEL_TS870S;
*RIG_MODEL_TS940 = *Hamlibc::RIG_MODEL_TS940;
*RIG_MODEL_TS950 = *Hamlibc::RIG_MODEL_TS950;
*RIG_MODEL_TS950SDX = *Hamlibc::RIG_MODEL_TS950SDX;
*RIG_MODEL_TS2000 = *Hamlibc::RIG_MODEL_TS2000;
*RIG_MODEL_R5000 = *Hamlibc::RIG_MODEL_R5000;
*RIG_MODEL_TS570S = *Hamlibc::RIG_MODEL_TS570S;
*RIG_MODEL_THD7A = *Hamlibc::RIG_MODEL_THD7A;
*RIG_MODEL_THD7AG = *Hamlibc::RIG_MODEL_THD7AG;
*RIG_MODEL_THF6A = *Hamlibc::RIG_MODEL_THF6A;
*RIG_MODEL_THF7E = *Hamlibc::RIG_MODEL_THF7E;
*RIG_MODEL_K2 = *Hamlibc::RIG_MODEL_K2;
*RIG_MODEL_TS930 = *Hamlibc::RIG_MODEL_TS930;
*RIG_MODEL_THG71 = *Hamlibc::RIG_MODEL_THG71;
*RIG_MODEL_TS680S = *Hamlibc::RIG_MODEL_TS680S;
*RIG_MODEL_TS140S = *Hamlibc::RIG_MODEL_TS140S;
*RIG_MODEL_TMD700 = *Hamlibc::RIG_MODEL_TMD700;
*RIG_MODEL_TMV7 = *Hamlibc::RIG_MODEL_TMV7;
*RIG_MODEL_TS480 = *Hamlibc::RIG_MODEL_TS480;
*RIG_MODEL_K3 = *Hamlibc::RIG_MODEL_K3;
*RIG_MODEL_IC1271 = *Hamlibc::RIG_MODEL_IC1271;
*RIG_MODEL_IC1275 = *Hamlibc::RIG_MODEL_IC1275;
*RIG_MODEL_IC271 = *Hamlibc::RIG_MODEL_IC271;
*RIG_MODEL_IC275 = *Hamlibc::RIG_MODEL_IC275;
*RIG_MODEL_IC375 = *Hamlibc::RIG_MODEL_IC375;
*RIG_MODEL_IC471 = *Hamlibc::RIG_MODEL_IC471;
*RIG_MODEL_IC475 = *Hamlibc::RIG_MODEL_IC475;
*RIG_MODEL_IC575 = *Hamlibc::RIG_MODEL_IC575;
*RIG_MODEL_IC706 = *Hamlibc::RIG_MODEL_IC706;
*RIG_MODEL_IC706MKII = *Hamlibc::RIG_MODEL_IC706MKII;
*RIG_MODEL_IC706MKIIG = *Hamlibc::RIG_MODEL_IC706MKIIG;
*RIG_MODEL_IC707 = *Hamlibc::RIG_MODEL_IC707;
*RIG_MODEL_IC718 = *Hamlibc::RIG_MODEL_IC718;
*RIG_MODEL_IC725 = *Hamlibc::RIG_MODEL_IC725;
*RIG_MODEL_IC726 = *Hamlibc::RIG_MODEL_IC726;
*RIG_MODEL_IC728 = *Hamlibc::RIG_MODEL_IC728;
*RIG_MODEL_IC729 = *Hamlibc::RIG_MODEL_IC729;
*RIG_MODEL_IC731 = *Hamlibc::RIG_MODEL_IC731;
*RIG_MODEL_IC735 = *Hamlibc::RIG_MODEL_IC735;
*RIG_MODEL_IC736 = *Hamlibc::RIG_MODEL_IC736;
*RIG_MODEL_IC737 = *Hamlibc::RIG_MODEL_IC737;
*RIG_MODEL_IC738 = *Hamlibc::RIG_MODEL_IC738;
*RIG_MODEL_IC746 = *Hamlibc::RIG_MODEL_IC746;
*RIG_MODEL_IC751 = *Hamlibc::RIG_MODEL_IC751;
*RIG_MODEL_IC751A = *Hamlibc::RIG_MODEL_IC751A;
*RIG_MODEL_IC756 = *Hamlibc::RIG_MODEL_IC756;
*RIG_MODEL_IC756PRO = *Hamlibc::RIG_MODEL_IC756PRO;
*RIG_MODEL_IC761 = *Hamlibc::RIG_MODEL_IC761;
*RIG_MODEL_IC765 = *Hamlibc::RIG_MODEL_IC765;
*RIG_MODEL_IC775 = *Hamlibc::RIG_MODEL_IC775;
*RIG_MODEL_IC781 = *Hamlibc::RIG_MODEL_IC781;
*RIG_MODEL_IC820 = *Hamlibc::RIG_MODEL_IC820;
*RIG_MODEL_IC821 = *Hamlibc::RIG_MODEL_IC821;
*RIG_MODEL_IC821H = *Hamlibc::RIG_MODEL_IC821H;
*RIG_MODEL_IC970 = *Hamlibc::RIG_MODEL_IC970;
*RIG_MODEL_ICR10 = *Hamlibc::RIG_MODEL_ICR10;
*RIG_MODEL_ICR71 = *Hamlibc::RIG_MODEL_ICR71;
*RIG_MODEL_ICR72 = *Hamlibc::RIG_MODEL_ICR72;
*RIG_MODEL_ICR75 = *Hamlibc::RIG_MODEL_ICR75;
*RIG_MODEL_ICR7000 = *Hamlibc::RIG_MODEL_ICR7000;
*RIG_MODEL_ICR7100 = *Hamlibc::RIG_MODEL_ICR7100;
*RIG_MODEL_ICR8500 = *Hamlibc::RIG_MODEL_ICR8500;
*RIG_MODEL_ICR9000 = *Hamlibc::RIG_MODEL_ICR9000;
*RIG_MODEL_IC910 = *Hamlibc::RIG_MODEL_IC910;
*RIG_MODEL_IC78 = *Hamlibc::RIG_MODEL_IC78;
*RIG_MODEL_IC746PRO = *Hamlibc::RIG_MODEL_IC746PRO;
*RIG_MODEL_IC756PROII = *Hamlibc::RIG_MODEL_IC756PROII;
*RIG_MODEL_ICID1 = *Hamlibc::RIG_MODEL_ICID1;
*RIG_MODEL_IC703 = *Hamlibc::RIG_MODEL_IC703;
*RIG_MODEL_IC7800 = *Hamlibc::RIG_MODEL_IC7800;
*RIG_MODEL_IC756PROIII = *Hamlibc::RIG_MODEL_IC756PROIII;
*RIG_MODEL_ICR20 = *Hamlibc::RIG_MODEL_ICR20;
*RIG_MODEL_IC7000 = *Hamlibc::RIG_MODEL_IC7000;
*RIG_MODEL_MINISCOUT = *Hamlibc::RIG_MODEL_MINISCOUT;
*RIG_MODEL_XPLORER = *Hamlibc::RIG_MODEL_XPLORER;
*RIG_MODEL_OS535 = *Hamlibc::RIG_MODEL_OS535;
*RIG_MODEL_OS456 = *Hamlibc::RIG_MODEL_OS456;
*RIG_MODEL_OMNIVI = *Hamlibc::RIG_MODEL_OMNIVI;
*RIG_MODEL_OMNIVIP = *Hamlibc::RIG_MODEL_OMNIVIP;
*RIG_MODEL_PARAGON2 = *Hamlibc::RIG_MODEL_PARAGON2;
*RIG_MODEL_PCR1000 = *Hamlibc::RIG_MODEL_PCR1000;
*RIG_MODEL_PCR100 = *Hamlibc::RIG_MODEL_PCR100;
*RIG_MODEL_AR8200 = *Hamlibc::RIG_MODEL_AR8200;
*RIG_MODEL_AR8000 = *Hamlibc::RIG_MODEL_AR8000;
*RIG_MODEL_AR7030 = *Hamlibc::RIG_MODEL_AR7030;
*RIG_MODEL_AR5000 = *Hamlibc::RIG_MODEL_AR5000;
*RIG_MODEL_AR3030 = *Hamlibc::RIG_MODEL_AR3030;
*RIG_MODEL_AR3000A = *Hamlibc::RIG_MODEL_AR3000A;
*RIG_MODEL_AR3000 = *Hamlibc::RIG_MODEL_AR3000;
*RIG_MODEL_AR2700 = *Hamlibc::RIG_MODEL_AR2700;
*RIG_MODEL_AR2500 = *Hamlibc::RIG_MODEL_AR2500;
*RIG_MODEL_AR16 = *Hamlibc::RIG_MODEL_AR16;
*RIG_MODEL_SDU5500 = *Hamlibc::RIG_MODEL_SDU5500;
*RIG_MODEL_SDU5000 = *Hamlibc::RIG_MODEL_SDU5000;
*RIG_MODEL_AR8600 = *Hamlibc::RIG_MODEL_AR8600;
*RIG_MODEL_AR5000A = *Hamlibc::RIG_MODEL_AR5000A;
*RIG_MODEL_JST145 = *Hamlibc::RIG_MODEL_JST145;
*RIG_MODEL_JST245 = *Hamlibc::RIG_MODEL_JST245;
*RIG_MODEL_CMH530 = *Hamlibc::RIG_MODEL_CMH530;
*RIG_MODEL_NRD345 = *Hamlibc::RIG_MODEL_NRD345;
*RIG_MODEL_NRD525 = *Hamlibc::RIG_MODEL_NRD525;
*RIG_MODEL_NRD535 = *Hamlibc::RIG_MODEL_NRD535;
*RIG_MODEL_NRD545 = *Hamlibc::RIG_MODEL_NRD545;
*RIG_MODEL_RS64 = *Hamlibc::RIG_MODEL_RS64;
*RIG_MODEL_RS2005 = *Hamlibc::RIG_MODEL_RS2005;
*RIG_MODEL_RS2006 = *Hamlibc::RIG_MODEL_RS2006;
*RIG_MODEL_RS2035 = *Hamlibc::RIG_MODEL_RS2035;
*RIG_MODEL_RS2042 = *Hamlibc::RIG_MODEL_RS2042;
*RIG_MODEL_RS2041 = *Hamlibc::RIG_MODEL_RS2041;
*RIG_MODEL_BC780 = *Hamlibc::RIG_MODEL_BC780;
*RIG_MODEL_BC245 = *Hamlibc::RIG_MODEL_BC245;
*RIG_MODEL_BC895 = *Hamlibc::RIG_MODEL_BC895;
*RIG_MODEL_PRO2052 = *Hamlibc::RIG_MODEL_PRO2052;
*RIG_MODEL_BC235 = *Hamlibc::RIG_MODEL_BC235;
*RIG_MODEL_BC250 = *Hamlibc::RIG_MODEL_BC250;
*RIG_MODEL_BC785 = *Hamlibc::RIG_MODEL_BC785;
*RIG_MODEL_BC786 = *Hamlibc::RIG_MODEL_BC786;
*RIG_MODEL_BCT8 = *Hamlibc::RIG_MODEL_BCT8;
*RIG_MODEL_BCD396T = *Hamlibc::RIG_MODEL_BCD396T;
*RIG_MODEL_BCD996T = *Hamlibc::RIG_MODEL_BCD996T;
*RIG_MODEL_DKR8 = *Hamlibc::RIG_MODEL_DKR8;
*RIG_MODEL_DKR8A = *Hamlibc::RIG_MODEL_DKR8A;
*RIG_MODEL_DKR8B = *Hamlibc::RIG_MODEL_DKR8B;
*RIG_MODEL_HF150 = *Hamlibc::RIG_MODEL_HF150;
*RIG_MODEL_HF225 = *Hamlibc::RIG_MODEL_HF225;
*RIG_MODEL_HF250 = *Hamlibc::RIG_MODEL_HF250;
*RIG_MODEL_HF235 = *Hamlibc::RIG_MODEL_HF235;
*RIG_MODEL_RA3790 = *Hamlibc::RIG_MODEL_RA3790;
*RIG_MODEL_RA3720 = *Hamlibc::RIG_MODEL_RA3720;
*RIG_MODEL_RA6790 = *Hamlibc::RIG_MODEL_RA6790;
*RIG_MODEL_RA3710 = *Hamlibc::RIG_MODEL_RA3710;
*RIG_MODEL_HF1000 = *Hamlibc::RIG_MODEL_HF1000;
*RIG_MODEL_HF1000A = *Hamlibc::RIG_MODEL_HF1000A;
*RIG_MODEL_WJ8711 = *Hamlibc::RIG_MODEL_WJ8711;
*RIG_MODEL_WJ8888 = *Hamlibc::RIG_MODEL_WJ8888;
*RIG_MODEL_ESM500 = *Hamlibc::RIG_MODEL_ESM500;
*RIG_MODEL_EK890 = *Hamlibc::RIG_MODEL_EK890;
*RIG_MODEL_EK891 = *Hamlibc::RIG_MODEL_EK891;
*RIG_MODEL_EK895 = *Hamlibc::RIG_MODEL_EK895;
*RIG_MODEL_EK070 = *Hamlibc::RIG_MODEL_EK070;
*RIG_MODEL_TRP7000 = *Hamlibc::RIG_MODEL_TRP7000;
*RIG_MODEL_TRP8000 = *Hamlibc::RIG_MODEL_TRP8000;
*RIG_MODEL_TRP9000 = *Hamlibc::RIG_MODEL_TRP9000;
*RIG_MODEL_WR1000 = *Hamlibc::RIG_MODEL_WR1000;
*RIG_MODEL_WR1500 = *Hamlibc::RIG_MODEL_WR1500;
*RIG_MODEL_WR1550 = *Hamlibc::RIG_MODEL_WR1550;
*RIG_MODEL_WR3100 = *Hamlibc::RIG_MODEL_WR3100;
*RIG_MODEL_WR3150 = *Hamlibc::RIG_MODEL_WR3150;
*RIG_MODEL_WR3500 = *Hamlibc::RIG_MODEL_WR3500;
*RIG_MODEL_WR3700 = *Hamlibc::RIG_MODEL_WR3700;
*RIG_MODEL_G303 = *Hamlibc::RIG_MODEL_G303;
*RIG_MODEL_G313 = *Hamlibc::RIG_MODEL_G313;
*RIG_MODEL_TT550 = *Hamlibc::RIG_MODEL_TT550;
*RIG_MODEL_TT538 = *Hamlibc::RIG_MODEL_TT538;
*RIG_MODEL_RX320 = *Hamlibc::RIG_MODEL_RX320;
*RIG_MODEL_RX340 = *Hamlibc::RIG_MODEL_RX340;
*RIG_MODEL_RX350 = *Hamlibc::RIG_MODEL_RX350;
*RIG_MODEL_TT526 = *Hamlibc::RIG_MODEL_TT526;
*RIG_MODEL_TT516 = *Hamlibc::RIG_MODEL_TT516;
*RIG_MODEL_TT565 = *Hamlibc::RIG_MODEL_TT565;
*RIG_MODEL_TT585 = *Hamlibc::RIG_MODEL_TT585;
*RIG_MODEL_DELTAII = *Hamlibc::RIG_MODEL_DELTAII;
*RIG_MODEL_TT588 = *Hamlibc::RIG_MODEL_TT588;
*RIG_MODEL_DX77 = *Hamlibc::RIG_MODEL_DX77;
*RIG_MODEL_505DSP = *Hamlibc::RIG_MODEL_505DSP;
*RIG_MODEL_RPC = *Hamlibc::RIG_MODEL_RPC;
*RIG_MODEL_GNURADIO = *Hamlibc::RIG_MODEL_GNURADIO;
*RIG_MODEL_MC4020 = *Hamlibc::RIG_MODEL_MC4020;
*RIG_MODEL_GRAUDIO = *Hamlibc::RIG_MODEL_GRAUDIO;
*RIG_MODEL_GRAUDIOIQ = *Hamlibc::RIG_MODEL_GRAUDIOIQ;
*RIG_MODEL_USRP_G = *Hamlibc::RIG_MODEL_USRP_G;
*RIG_MODEL_MICROTUNE_4937 = *Hamlibc::RIG_MODEL_MICROTUNE_4937;
*RIG_MODEL_MICROTUNE_4702 = *Hamlibc::RIG_MODEL_MICROTUNE_4702;
*RIG_MODEL_MICROTUNE_4707 = *Hamlibc::RIG_MODEL_MICROTUNE_4707;
*RIG_MODEL_DSP10 = *Hamlibc::RIG_MODEL_DSP10;
*RIG_MODEL_SDR1000 = *Hamlibc::RIG_MODEL_SDR1000;
*RIG_MODEL_SDR1000RFE = *Hamlibc::RIG_MODEL_SDR1000RFE;
*RIG_MODEL_DTTSP = *Hamlibc::RIG_MODEL_DTTSP;
*RIG_MODEL_EKD500 = *Hamlibc::RIG_MODEL_EKD500;
*RIG_MODEL_ELEKTOR304 = *Hamlibc::RIG_MODEL_ELEKTOR304;
*RIG_MODEL_DRT1 = *Hamlibc::RIG_MODEL_DRT1;
*RIG_MODEL_DWT = *Hamlibc::RIG_MODEL_DWT;
*RIG_MODEL_USRP0 = *Hamlibc::RIG_MODEL_USRP0;
*RIG_MODEL_USRP = *Hamlibc::RIG_MODEL_USRP;
*RIG_MODEL_DDS60 = *Hamlibc::RIG_MODEL_DDS60;
*RIG_MODEL_ELEKTOR507 = *Hamlibc::RIG_MODEL_ELEKTOR507;
*RIG_MODEL_MINIVNA = *Hamlibc::RIG_MODEL_MINIVNA;
*RIG_MODEL_SI570AVRUSB = *Hamlibc::RIG_MODEL_SI570AVRUSB;
*RIG_MODEL_V4L = *Hamlibc::RIG_MODEL_V4L;
*hamlib_version = *Hamlibc::hamlib_version;
*hamlib_copyright = *Hamlibc::hamlib_copyright;
*RIG_OK = *Hamlibc::RIG_OK;
*RIG_EINVAL = *Hamlibc::RIG_EINVAL;
*RIG_ECONF = *Hamlibc::RIG_ECONF;
*RIG_ENOMEM = *Hamlibc::RIG_ENOMEM;
*RIG_ENIMPL = *Hamlibc::RIG_ENIMPL;
*RIG_ETIMEOUT = *Hamlibc::RIG_ETIMEOUT;
*RIG_EIO = *Hamlibc::RIG_EIO;
*RIG_EINTERNAL = *Hamlibc::RIG_EINTERNAL;
*RIG_EPROTO = *Hamlibc::RIG_EPROTO;
*RIG_ERJCTED = *Hamlibc::RIG_ERJCTED;
*RIG_ETRUNC = *Hamlibc::RIG_ETRUNC;
*RIG_ENAVAIL = *Hamlibc::RIG_ENAVAIL;
*RIG_ENTARGET = *Hamlibc::RIG_ENTARGET;
*RIG_BUSERROR = *Hamlibc::RIG_BUSERROR;
*RIG_BUSBUSY = *Hamlibc::RIG_BUSBUSY;
*RIG_EARG = *Hamlibc::RIG_EARG;
*RIG_EVFO = *Hamlibc::RIG_EVFO;
*RIG_EDOM = *Hamlibc::RIG_EDOM;
*NETRIGCTL_RET = *Hamlibc::NETRIGCTL_RET;
*RIG_DEBUG_NONE = *Hamlibc::RIG_DEBUG_NONE;
*RIG_DEBUG_BUG = *Hamlibc::RIG_DEBUG_BUG;
*RIG_DEBUG_ERR = *Hamlibc::RIG_DEBUG_ERR;
*RIG_DEBUG_WARN = *Hamlibc::RIG_DEBUG_WARN;
*RIG_DEBUG_VERBOSE = *Hamlibc::RIG_DEBUG_VERBOSE;
*RIG_DEBUG_TRACE = *Hamlibc::RIG_DEBUG_TRACE;
*RIGNAMSIZ = *Hamlibc::RIGNAMSIZ;
*RIGVERSIZ = *Hamlibc::RIGVERSIZ;
*FILPATHLEN = *Hamlibc::FILPATHLEN;
*FRQRANGESIZ = *Hamlibc::FRQRANGESIZ;
*MAXCHANDESC = *Hamlibc::MAXCHANDESC;
*TSLSTSIZ = *Hamlibc::TSLSTSIZ;
*FLTLSTSIZ = *Hamlibc::FLTLSTSIZ;
*MAXDBLSTSIZ = *Hamlibc::MAXDBLSTSIZ;
*CHANLSTSIZ = *Hamlibc::CHANLSTSIZ;
*MAX_CAL_LENGTH = *Hamlibc::MAX_CAL_LENGTH;
*RIG_PORT_NONE = *Hamlibc::RIG_PORT_NONE;
*RIG_PORT_SERIAL = *Hamlibc::RIG_PORT_SERIAL;
*RIG_PORT_NETWORK = *Hamlibc::RIG_PORT_NETWORK;
*RIG_PORT_DEVICE = *Hamlibc::RIG_PORT_DEVICE;
*RIG_PORT_PACKET = *Hamlibc::RIG_PORT_PACKET;
*RIG_PORT_DTMF = *Hamlibc::RIG_PORT_DTMF;
*RIG_PORT_ULTRA = *Hamlibc::RIG_PORT_ULTRA;
*RIG_PORT_RPC = *Hamlibc::RIG_PORT_RPC;
*RIG_PORT_PARALLEL = *Hamlibc::RIG_PORT_PARALLEL;
*RIG_PORT_USB = *Hamlibc::RIG_PORT_USB;
*RIG_PARITY_NONE = *Hamlibc::RIG_PARITY_NONE;
*RIG_PARITY_ODD = *Hamlibc::RIG_PARITY_ODD;
*RIG_PARITY_EVEN = *Hamlibc::RIG_PARITY_EVEN;
*RIG_HANDSHAKE_NONE = *Hamlibc::RIG_HANDSHAKE_NONE;
*RIG_HANDSHAKE_XONXOFF = *Hamlibc::RIG_HANDSHAKE_XONXOFF;
*RIG_HANDSHAKE_HARDWARE = *Hamlibc::RIG_HANDSHAKE_HARDWARE;
*RIG_SIGNAL_UNSET = *Hamlibc::RIG_SIGNAL_UNSET;
*RIG_SIGNAL_ON = *Hamlibc::RIG_SIGNAL_ON;
*RIG_SIGNAL_OFF = *Hamlibc::RIG_SIGNAL_OFF;
*RIG_FLAG_RECEIVER = *Hamlibc::RIG_FLAG_RECEIVER;
*RIG_FLAG_TRANSMITTER = *Hamlibc::RIG_FLAG_TRANSMITTER;
*RIG_FLAG_SCANNER = *Hamlibc::RIG_FLAG_SCANNER;
*RIG_FLAG_MOBILE = *Hamlibc::RIG_FLAG_MOBILE;
*RIG_FLAG_HANDHELD = *Hamlibc::RIG_FLAG_HANDHELD;
*RIG_FLAG_COMPUTER = *Hamlibc::RIG_FLAG_COMPUTER;
*RIG_FLAG_TRUNKING = *Hamlibc::RIG_FLAG_TRUNKING;
*RIG_FLAG_APRS = *Hamlibc::RIG_FLAG_APRS;
*RIG_FLAG_TNC = *Hamlibc::RIG_FLAG_TNC;
*RIG_FLAG_DXCLUSTER = *Hamlibc::RIG_FLAG_DXCLUSTER;
*RIG_FLAG_TUNER = *Hamlibc::RIG_FLAG_TUNER;
*RIG_TYPE_OTHER = *Hamlibc::RIG_TYPE_OTHER;
*RIG_STATUS_ALPHA = *Hamlibc::RIG_STATUS_ALPHA;
*RIG_STATUS_UNTESTED = *Hamlibc::RIG_STATUS_UNTESTED;
*RIG_STATUS_BETA = *Hamlibc::RIG_STATUS_BETA;
*RIG_STATUS_STABLE = *Hamlibc::RIG_STATUS_STABLE;
*RIG_STATUS_BUGGY = *Hamlibc::RIG_STATUS_BUGGY;
*RIG_RPT_SHIFT_NONE = *Hamlibc::RIG_RPT_SHIFT_NONE;
*RIG_RPT_SHIFT_MINUS = *Hamlibc::RIG_RPT_SHIFT_MINUS;
*RIG_RPT_SHIFT_PLUS = *Hamlibc::RIG_RPT_SHIFT_PLUS;
*RIG_SPLIT_OFF = *Hamlibc::RIG_SPLIT_OFF;
*RIG_SPLIT_ON = *Hamlibc::RIG_SPLIT_ON;
*RIG_VFO_NONE = *Hamlibc::RIG_VFO_NONE;
*RIG_VFO_TX_FLAG = *Hamlibc::RIG_VFO_TX_FLAG;
*RIG_VFO_CURR = *Hamlibc::RIG_VFO_CURR;
*RIG_VFO_MEM = *Hamlibc::RIG_VFO_MEM;
*RIG_VFO_VFO = *Hamlibc::RIG_VFO_VFO;
*RIG_VFO_TX = *Hamlibc::RIG_VFO_TX;
*RIG_VFO_RX = *Hamlibc::RIG_VFO_RX;
*RIG_VFO_MAIN = *Hamlibc::RIG_VFO_MAIN;
*RIG_VFO_SUB = *Hamlibc::RIG_VFO_SUB;
*RIG_VFO_A = *Hamlibc::RIG_VFO_A;
*RIG_VFO_B = *Hamlibc::RIG_VFO_B;
*RIG_VFO_C = *Hamlibc::RIG_VFO_C;
*RIG_TARGETABLE_NONE = *Hamlibc::RIG_TARGETABLE_NONE;
*RIG_TARGETABLE_FREQ = *Hamlibc::RIG_TARGETABLE_FREQ;
*RIG_TARGETABLE_MODE = *Hamlibc::RIG_TARGETABLE_MODE;
*RIG_TARGETABLE_PURE = *Hamlibc::RIG_TARGETABLE_PURE;
*RIG_TARGETABLE_ALL = *Hamlibc::RIG_TARGETABLE_ALL;
*RIG_DCD_OFF = *Hamlibc::RIG_DCD_OFF;
*RIG_DCD_ON = *Hamlibc::RIG_DCD_ON;
*RIG_DCD_NONE = *Hamlibc::RIG_DCD_NONE;
*RIG_DCD_RIG = *Hamlibc::RIG_DCD_RIG;
*RIG_DCD_SERIAL_DSR = *Hamlibc::RIG_DCD_SERIAL_DSR;
*RIG_DCD_SERIAL_CTS = *Hamlibc::RIG_DCD_SERIAL_CTS;
*RIG_DCD_SERIAL_CAR = *Hamlibc::RIG_DCD_SERIAL_CAR;
*RIG_DCD_PARALLEL = *Hamlibc::RIG_DCD_PARALLEL;
*RIG_PTT_OFF = *Hamlibc::RIG_PTT_OFF;
*RIG_PTT_ON = *Hamlibc::RIG_PTT_ON;
*RIG_PTT_NONE = *Hamlibc::RIG_PTT_NONE;
*RIG_PTT_RIG = *Hamlibc::RIG_PTT_RIG;
*RIG_PTT_SERIAL_DTR = *Hamlibc::RIG_PTT_SERIAL_DTR;
*RIG_PTT_SERIAL_RTS = *Hamlibc::RIG_PTT_SERIAL_RTS;
*RIG_PTT_PARALLEL = *Hamlibc::RIG_PTT_PARALLEL;
*RIG_POWER_OFF = *Hamlibc::RIG_POWER_OFF;
*RIG_POWER_ON = *Hamlibc::RIG_POWER_ON;
*RIG_POWER_STANDBY = *Hamlibc::RIG_POWER_STANDBY;
*RIG_RESET_NONE = *Hamlibc::RIG_RESET_NONE;
*RIG_RESET_SOFT = *Hamlibc::RIG_RESET_SOFT;
*RIG_RESET_VFO = *Hamlibc::RIG_RESET_VFO;
*RIG_RESET_MCALL = *Hamlibc::RIG_RESET_MCALL;
*RIG_RESET_MASTER = *Hamlibc::RIG_RESET_MASTER;
*RIG_OP_NONE = *Hamlibc::RIG_OP_NONE;
*RIG_OP_CPY = *Hamlibc::RIG_OP_CPY;
*RIG_OP_XCHG = *Hamlibc::RIG_OP_XCHG;
*RIG_OP_FROM_VFO = *Hamlibc::RIG_OP_FROM_VFO;
*RIG_OP_TO_VFO = *Hamlibc::RIG_OP_TO_VFO;
*RIG_OP_MCL = *Hamlibc::RIG_OP_MCL;
*RIG_OP_UP = *Hamlibc::RIG_OP_UP;
*RIG_OP_DOWN = *Hamlibc::RIG_OP_DOWN;
*RIG_OP_BAND_UP = *Hamlibc::RIG_OP_BAND_UP;
*RIG_OP_BAND_DOWN = *Hamlibc::RIG_OP_BAND_DOWN;
*RIG_OP_LEFT = *Hamlibc::RIG_OP_LEFT;
*RIG_OP_RIGHT = *Hamlibc::RIG_OP_RIGHT;
*RIG_OP_TUNE = *Hamlibc::RIG_OP_TUNE;
*RIG_OP_TOGGLE = *Hamlibc::RIG_OP_TOGGLE;
*RIG_SCAN_NONE = *Hamlibc::RIG_SCAN_NONE;
*RIG_SCAN_STOP = *Hamlibc::RIG_SCAN_STOP;
*RIG_SCAN_MEM = *Hamlibc::RIG_SCAN_MEM;
*RIG_SCAN_SLCT = *Hamlibc::RIG_SCAN_SLCT;
*RIG_SCAN_PRIO = *Hamlibc::RIG_SCAN_PRIO;
*RIG_SCAN_PROG = *Hamlibc::RIG_SCAN_PROG;
*RIG_SCAN_DELTA = *Hamlibc::RIG_SCAN_DELTA;
*RIG_SCAN_VFO = *Hamlibc::RIG_SCAN_VFO;
*RIG_SCAN_PLT = *Hamlibc::RIG_SCAN_PLT;
*RIG_CONF_END = *Hamlibc::RIG_CONF_END;
*RIG_CONF_STRING = *Hamlibc::RIG_CONF_STRING;
*RIG_CONF_COMBO = *Hamlibc::RIG_CONF_COMBO;
*RIG_CONF_NUMERIC = *Hamlibc::RIG_CONF_NUMERIC;
*RIG_CONF_CHECKBUTTON = *Hamlibc::RIG_CONF_CHECKBUTTON;
*RIG_COMBO_MAX = *Hamlibc::RIG_COMBO_MAX;
*RIG_ANN_NONE = *Hamlibc::RIG_ANN_NONE;
*RIG_ANN_OFF = *Hamlibc::RIG_ANN_OFF;
*RIG_ANN_FREQ = *Hamlibc::RIG_ANN_FREQ;
*RIG_ANN_RXMODE = *Hamlibc::RIG_ANN_RXMODE;
*RIG_ANN_CW = *Hamlibc::RIG_ANN_CW;
*RIG_ANN_ENG = *Hamlibc::RIG_ANN_ENG;
*RIG_ANN_JAP = *Hamlibc::RIG_ANN_JAP;
*RIG_ANT_NONE = *Hamlibc::RIG_ANT_NONE;
*RIG_AGC_OFF = *Hamlibc::RIG_AGC_OFF;
*RIG_AGC_SUPERFAST = *Hamlibc::RIG_AGC_SUPERFAST;
*RIG_AGC_FAST = *Hamlibc::RIG_AGC_FAST;
*RIG_AGC_SLOW = *Hamlibc::RIG_AGC_SLOW;
*RIG_AGC_USER = *Hamlibc::RIG_AGC_USER;
*RIG_AGC_MEDIUM = *Hamlibc::RIG_AGC_MEDIUM;
*RIG_METER_NONE = *Hamlibc::RIG_METER_NONE;
*RIG_METER_SWR = *Hamlibc::RIG_METER_SWR;
*RIG_METER_COMP = *Hamlibc::RIG_METER_COMP;
*RIG_METER_ALC = *Hamlibc::RIG_METER_ALC;
*RIG_METER_IC = *Hamlibc::RIG_METER_IC;
*RIG_METER_DB = *Hamlibc::RIG_METER_DB;
*RIG_METER_PO = *Hamlibc::RIG_METER_PO;
*RIG_LEVEL_NONE = *Hamlibc::RIG_LEVEL_NONE;
*RIG_LEVEL_PREAMP = *Hamlibc::RIG_LEVEL_PREAMP;
*RIG_LEVEL_ATT = *Hamlibc::RIG_LEVEL_ATT;
*RIG_LEVEL_VOX = *Hamlibc::RIG_LEVEL_VOX;
*RIG_LEVEL_AF = *Hamlibc::RIG_LEVEL_AF;
*RIG_LEVEL_RF = *Hamlibc::RIG_LEVEL_RF;
*RIG_LEVEL_SQL = *Hamlibc::RIG_LEVEL_SQL;
*RIG_LEVEL_IF = *Hamlibc::RIG_LEVEL_IF;
*RIG_LEVEL_APF = *Hamlibc::RIG_LEVEL_APF;
*RIG_LEVEL_NR = *Hamlibc::RIG_LEVEL_NR;
*RIG_LEVEL_PBT_IN = *Hamlibc::RIG_LEVEL_PBT_IN;
*RIG_LEVEL_PBT_OUT = *Hamlibc::RIG_LEVEL_PBT_OUT;
*RIG_LEVEL_CWPITCH = *Hamlibc::RIG_LEVEL_CWPITCH;
*RIG_LEVEL_RFPOWER = *Hamlibc::RIG_LEVEL_RFPOWER;
*RIG_LEVEL_MICGAIN = *Hamlibc::RIG_LEVEL_MICGAIN;
*RIG_LEVEL_KEYSPD = *Hamlibc::RIG_LEVEL_KEYSPD;
*RIG_LEVEL_NOTCHF = *Hamlibc::RIG_LEVEL_NOTCHF;
*RIG_LEVEL_COMP = *Hamlibc::RIG_LEVEL_COMP;
*RIG_LEVEL_AGC = *Hamlibc::RIG_LEVEL_AGC;
*RIG_LEVEL_BKINDL = *Hamlibc::RIG_LEVEL_BKINDL;
*RIG_LEVEL_BALANCE = *Hamlibc::RIG_LEVEL_BALANCE;
*RIG_LEVEL_METER = *Hamlibc::RIG_LEVEL_METER;
*RIG_LEVEL_VOXGAIN = *Hamlibc::RIG_LEVEL_VOXGAIN;
*RIG_LEVEL_VOXDELAY = *Hamlibc::RIG_LEVEL_VOXDELAY;
*RIG_LEVEL_ANTIVOX = *Hamlibc::RIG_LEVEL_ANTIVOX;
*RIG_LEVEL_SLOPE_LOW = *Hamlibc::RIG_LEVEL_SLOPE_LOW;
*RIG_LEVEL_SLOPE_HIGH = *Hamlibc::RIG_LEVEL_SLOPE_HIGH;
*RIG_LEVEL_RAWSTR = *Hamlibc::RIG_LEVEL_RAWSTR;
*RIG_LEVEL_SQLSTAT = *Hamlibc::RIG_LEVEL_SQLSTAT;
*RIG_LEVEL_SWR = *Hamlibc::RIG_LEVEL_SWR;
*RIG_LEVEL_ALC = *Hamlibc::RIG_LEVEL_ALC;
*RIG_LEVEL_STRENGTH = *Hamlibc::RIG_LEVEL_STRENGTH;
*RIG_PARM_NONE = *Hamlibc::RIG_PARM_NONE;
*RIG_PARM_ANN = *Hamlibc::RIG_PARM_ANN;
*RIG_PARM_APO = *Hamlibc::RIG_PARM_APO;
*RIG_PARM_BACKLIGHT = *Hamlibc::RIG_PARM_BACKLIGHT;
*RIG_PARM_BEEP = *Hamlibc::RIG_PARM_BEEP;
*RIG_PARM_TIME = *Hamlibc::RIG_PARM_TIME;
*RIG_PARM_BAT = *Hamlibc::RIG_PARM_BAT;
*RIG_PARM_KEYLIGHT = *Hamlibc::RIG_PARM_KEYLIGHT;
*RIG_SETTING_MAX = *Hamlibc::RIG_SETTING_MAX;
*RIG_TRN_OFF = *Hamlibc::RIG_TRN_OFF;
*RIG_TRN_RIG = *Hamlibc::RIG_TRN_RIG;
*RIG_TRN_POLL = *Hamlibc::RIG_TRN_POLL;
*RIG_FUNC_NONE = *Hamlibc::RIG_FUNC_NONE;
*RIG_FUNC_FAGC = *Hamlibc::RIG_FUNC_FAGC;
*RIG_FUNC_NB = *Hamlibc::RIG_FUNC_NB;
*RIG_FUNC_COMP = *Hamlibc::RIG_FUNC_COMP;
*RIG_FUNC_VOX = *Hamlibc::RIG_FUNC_VOX;
*RIG_FUNC_TONE = *Hamlibc::RIG_FUNC_TONE;
*RIG_FUNC_TSQL = *Hamlibc::RIG_FUNC_TSQL;
*RIG_FUNC_SBKIN = *Hamlibc::RIG_FUNC_SBKIN;
*RIG_FUNC_FBKIN = *Hamlibc::RIG_FUNC_FBKIN;
*RIG_FUNC_ANF = *Hamlibc::RIG_FUNC_ANF;
*RIG_FUNC_NR = *Hamlibc::RIG_FUNC_NR;
*RIG_FUNC_AIP = *Hamlibc::RIG_FUNC_AIP;
*RIG_FUNC_APF = *Hamlibc::RIG_FUNC_APF;
*RIG_FUNC_MON = *Hamlibc::RIG_FUNC_MON;
*RIG_FUNC_MN = *Hamlibc::RIG_FUNC_MN;
*RIG_FUNC_RF = *Hamlibc::RIG_FUNC_RF;
*RIG_FUNC_ARO = *Hamlibc::RIG_FUNC_ARO;
*RIG_FUNC_LOCK = *Hamlibc::RIG_FUNC_LOCK;
*RIG_FUNC_MUTE = *Hamlibc::RIG_FUNC_MUTE;
*RIG_FUNC_VSC = *Hamlibc::RIG_FUNC_VSC;
*RIG_FUNC_REV = *Hamlibc::RIG_FUNC_REV;
*RIG_FUNC_SQL = *Hamlibc::RIG_FUNC_SQL;
*RIG_FUNC_ABM = *Hamlibc::RIG_FUNC_ABM;
*RIG_FUNC_BC = *Hamlibc::RIG_FUNC_BC;
*RIG_FUNC_MBC = *Hamlibc::RIG_FUNC_MBC;
*RIG_FUNC_AFC = *Hamlibc::RIG_FUNC_AFC;
*RIG_FUNC_SATMODE = *Hamlibc::RIG_FUNC_SATMODE;
*RIG_FUNC_SCOPE = *Hamlibc::RIG_FUNC_SCOPE;
*RIG_FUNC_RESUME = *Hamlibc::RIG_FUNC_RESUME;
*RIG_FUNC_TBURST = *Hamlibc::RIG_FUNC_TBURST;
*RIG_FUNC_TUNER = *Hamlibc::RIG_FUNC_TUNER;
*RIG_MODE_NONE = *Hamlibc::RIG_MODE_NONE;
*RIG_MODE_AM = *Hamlibc::RIG_MODE_AM;
*RIG_MODE_CW = *Hamlibc::RIG_MODE_CW;
*RIG_MODE_USB = *Hamlibc::RIG_MODE_USB;
*RIG_MODE_LSB = *Hamlibc::RIG_MODE_LSB;
*RIG_MODE_RTTY = *Hamlibc::RIG_MODE_RTTY;
*RIG_MODE_FM = *Hamlibc::RIG_MODE_FM;
*RIG_MODE_WFM = *Hamlibc::RIG_MODE_WFM;
*RIG_MODE_CWR = *Hamlibc::RIG_MODE_CWR;
*RIG_MODE_RTTYR = *Hamlibc::RIG_MODE_RTTYR;
*RIG_MODE_AMS = *Hamlibc::RIG_MODE_AMS;
*RIG_MODE_PKTLSB = *Hamlibc::RIG_MODE_PKTLSB;
*RIG_MODE_PKTUSB = *Hamlibc::RIG_MODE_PKTUSB;
*RIG_MODE_PKTFM = *Hamlibc::RIG_MODE_PKTFM;
*RIG_MODE_ECSSUSB = *Hamlibc::RIG_MODE_ECSSUSB;
*RIG_MODE_ECSSLSB = *Hamlibc::RIG_MODE_ECSSLSB;
*RIG_MODE_FAX = *Hamlibc::RIG_MODE_FAX;
*RIG_MODE_SAM = *Hamlibc::RIG_MODE_SAM;
*RIG_MODE_SAL = *Hamlibc::RIG_MODE_SAL;
*RIG_MODE_SAH = *Hamlibc::RIG_MODE_SAH;
*RIG_MODE_DSB = *Hamlibc::RIG_MODE_DSB;
*RIG_DBLST_END = *Hamlibc::RIG_DBLST_END;
*RIG_ITU_REGION1 = *Hamlibc::RIG_ITU_REGION1;
*RIG_ITU_REGION2 = *Hamlibc::RIG_ITU_REGION2;
*RIG_ITU_REGION3 = *Hamlibc::RIG_ITU_REGION3;
*RIG_TS_ANY = *Hamlibc::RIG_TS_ANY;
*RIG_FLT_ANY = *Hamlibc::RIG_FLT_ANY;
*RIG_CHFLAG_NONE = *Hamlibc::RIG_CHFLAG_NONE;
*RIG_CHFLAG_SKIP = *Hamlibc::RIG_CHFLAG_SKIP;
*RIG_CHFLAG_DATA = *Hamlibc::RIG_CHFLAG_DATA;
*RIG_MTYPE_NONE = *Hamlibc::RIG_MTYPE_NONE;
*RIG_MTYPE_MEM = *Hamlibc::RIG_MTYPE_MEM;
*RIG_MTYPE_EDGE = *Hamlibc::RIG_MTYPE_EDGE;
*RIG_MTYPE_CALL = *Hamlibc::RIG_MTYPE_CALL;
*RIG_MTYPE_MEMOPAD = *Hamlibc::RIG_MTYPE_MEMOPAD;
*RIG_MTYPE_SAT = *Hamlibc::RIG_MTYPE_SAT;
*RIG_MTYPE_BAND = *Hamlibc::RIG_MTYPE_BAND;
*RIG_MTYPE_PRIO = *Hamlibc::RIG_MTYPE_PRIO;
*RIG_MEM_CAPS_ALL = *Hamlibc::RIG_MEM_CAPS_ALL;
*ROT_MODEL_NONE = *Hamlibc::ROT_MODEL_NONE;
*ROT_MODEL_DUMMY = *Hamlibc::ROT_MODEL_DUMMY;
*ROT_MODEL_NETROTCTL = *Hamlibc::ROT_MODEL_NETROTCTL;
*ROT_MODEL_RPC = *Hamlibc::ROT_MODEL_RPC;
*ROT_MODEL_EASYCOMM1 = *Hamlibc::ROT_MODEL_EASYCOMM1;
*ROT_MODEL_EASYCOMM2 = *Hamlibc::ROT_MODEL_EASYCOMM2;
*ROT_MODEL_FODTRACK = *Hamlibc::ROT_MODEL_FODTRACK;
*ROT_MODEL_ROTOREZ = *Hamlibc::ROT_MODEL_ROTOREZ;
*ROT_MODEL_ROTORCARD = *Hamlibc::ROT_MODEL_ROTORCARD;
*ROT_MODEL_DCU = *Hamlibc::ROT_MODEL_DCU;
*ROT_MODEL_SARTEK1 = *Hamlibc::ROT_MODEL_SARTEK1;
*ROT_MODEL_GS232A = *Hamlibc::ROT_MODEL_GS232A;
*ROT_MODEL_PCROTOR = *Hamlibc::ROT_MODEL_PCROTOR;
*NETROTCTL_RET = *Hamlibc::NETROTCTL_RET;
*ROT_RESET_ALL = *Hamlibc::ROT_RESET_ALL;
*ROT_FLAG_AZIMUTH = *Hamlibc::ROT_FLAG_AZIMUTH;
*ROT_FLAG_ELEVATION = *Hamlibc::ROT_FLAG_ELEVATION;
*ROT_TYPE_OTHER = *Hamlibc::ROT_TYPE_OTHER;
*ROT_MOVE_UP = *Hamlibc::ROT_MOVE_UP;
*ROT_MOVE_DOWN = *Hamlibc::ROT_MOVE_DOWN;
*ROT_MOVE_LEFT = *Hamlibc::ROT_MOVE_LEFT;
*ROT_MOVE_CCW = *Hamlibc::ROT_MOVE_CCW;
*ROT_MOVE_RIGHT = *Hamlibc::ROT_MOVE_RIGHT;
*ROT_MOVE_CW = *Hamlibc::ROT_MOVE_CW;
1;
