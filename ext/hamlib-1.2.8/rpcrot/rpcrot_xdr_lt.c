/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "rpcrot.h"
/*
 *  Hamlib Interface - RPC definitions
 *  Copyright (c) 2000-2002 by Stephane Fillod and Frank Singleton
 *  Contributed by Francois Retief <fgretief@sun.ac.za>
 *
 *	$Id: rpcrot.x,v 1.3 2005/03/28 09:37:24 fillods Exp $
 *
 *   This library is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU Library General Public License as
 *   published by the Free Software Foundation; either version 2 of
 *   the License, or (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU Library General Public License for more details.
 *
 *   You should have received a copy of the GNU Library General Public
 *   License along with this library; if not, write to the Free Software
 *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 */
#if __APPLE__
static int _rpcsvcdirty;
#endif

bool_t
xdr_model_x (XDR *xdrs, model_x *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_azimuth_x (XDR *xdrs, azimuth_x *objp)
{
	register int32_t *buf;

	 if (!xdr_float (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_elevation_x (XDR *xdrs, elevation_x *objp)
{
	register int32_t *buf;

	 if (!xdr_float (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_rot_reset_x (XDR *xdrs, rot_reset_x *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_position_arg (XDR *xdrs, position_arg *objp)
{
	register int32_t *buf;

	 if (!xdr_azimuth_x (xdrs, &objp->az))
		 return FALSE;
	 if (!xdr_elevation_x (xdrs, &objp->el))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_move_s (XDR *xdrs, move_s *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->direction))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->speed))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_position_s (XDR *xdrs, position_s *objp)
{
	register int32_t *buf;

	 if (!xdr_azimuth_x (xdrs, &objp->az))
		 return FALSE;
	 if (!xdr_elevation_x (xdrs, &objp->el))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_position_res (XDR *xdrs, position_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->rotstatus))
		 return FALSE;
	switch (objp->rotstatus) {
	case 0:
		 if (!xdr_position_s (xdrs, &objp->position_res_u.pos))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_rotstate_s (XDR *xdrs, rotstate_s *objp)
{
	register int32_t *buf;

	 if (!xdr_azimuth_x (xdrs, &objp->az_min))
		 return FALSE;
	 if (!xdr_azimuth_x (xdrs, &objp->az_max))
		 return FALSE;
	 if (!xdr_elevation_x (xdrs, &objp->el_min))
		 return FALSE;
	 if (!xdr_elevation_x (xdrs, &objp->el_max))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_rotstate_res (XDR *xdrs, rotstate_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->rotstatus))
		 return FALSE;
	switch (objp->rotstatus) {
	case 0:
		 if (!xdr_rotstate_s (xdrs, &objp->rotstate_res_u.state))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}
